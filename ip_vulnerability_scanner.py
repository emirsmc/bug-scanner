#!/usr/bin/env python3
"""
OWASP Top 10 Vulnerability Scanner
Professional security assessment tool with ethical guidelines
Author: Security Team
Version: 2.0
"""

import asyncio
import aiohttp
import json
import logging
import socket
import time
from datetime import datetime
from typing import Dict, List, Optional, Any
from urllib.parse import urljoin, urlparse
from html import escape
import sys

# ============================================================================
# CONFIGURATION & CONSTANTS
# ============================================================================

SEVERITY_SCORES = {
    "Critical": 9.0,
    "High": 7.0,
    "Medium": 5.0,
    "Low": 3.0,
    "Info": 1.0
}

# Top 1000 common ports
COMMON_PORTS = [
    21, 22, 25, 53, 80, 110, 143, 443, 445, 465, 587, 993, 995, 
    1433, 3306, 3389, 5432, 5984, 6379, 8000, 8080, 8443, 8888, 
    9200, 27017, 50070, 9090, 8082, 8086, 5000, 5005, 5900, 8161
]

# Configure logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(levelname)s - %(message)s',
    handlers=[
        logging.FileHandler('responses.log'),
        logging.StreamHandler()
    ]
)
logger = logging.getLogger(__name__)

# ============================================================================
# ETHICAL NOTICE & USER CONSENT
# ============================================================================

def show_ethical_notice():
    """Display ethical notice and obtain user consent"""
    notice = """
    ‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
    ‚ïë                      ETHICAL SECURITY NOTICE                           ‚ïë
    ‚ï†‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï£
    ‚ïë                                                                        ‚ïë
    ‚ïë  This tool is for AUTHORIZED USE ONLY.                               ‚ïë
    ‚ïë                                                                        ‚ïë
    ‚ïë  ‚ö†Ô∏è  LEGAL WARNING:                                                    ‚ïë
    ‚ïë     ‚Ä¢ Run scans only with explicit written permission                 ‚ïë
    ‚ïë     ‚Ä¢ Unauthorized access is illegal (Computer Fraud & Abuse Act)     ‚ïë
    ‚ïë     ‚Ä¢ Misuse may result in criminal prosecution                       ‚ïë
    ‚ïë                                                                        ‚ïë
    ‚ïë  ‚úì AUTHORIZED USE INCLUDES:                                          ‚ïë
    ‚ïë     ‚Ä¢ Testing your own systems                                        ‚ïë
    ‚ïë     ÔøΩÔøΩÔøΩ Penetration tests with written authorization                    ‚ïë
    ‚ïë     ‚Ä¢ Security research and training (with permission)                ‚ïë
    ‚ïë                                                                        ‚ïë
    ‚ïë  DISCLAIMER:                                                          ‚ïë
    ‚ïë  The author assumes NO liability for unauthorized use or damages      ‚ïë
    ‚ïë  resulting from this tool.                                            ‚ïë
    ‚ïë                                                                        ‚ïë
    ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù
    """
    print(notice)
    
    consent = input("Do you have explicit authorization to scan the target? (YES/no): ").strip().upper()
    if consent != "YES":
        print("‚ùå Scan aborted. Authorization required to proceed.")
        sys.exit(0)
    print("‚úì Authorization confirmed. Proceeding with scan...\n")

# ============================================================================
# PORT SCANNING
# ============================================================================

async def check_port(host: str, port: int, timeout: int = 2) -> Optional[int]:
    """Asynchronously check if a port is open"""
    try:
        conn = asyncio.open_connection(host, port)
        await asyncio.wait_for(conn, timeout=timeout)
        return port
    except (asyncio.TimeoutError, OSError, ConnectionRefusedError):
        return None

async def scan_ports(host: str, ports: List[int] = None, timeout: int = 2) -> List[int]:
    """Scan multiple ports concurrently"""
    if ports is None:
        ports = COMMON_PORTS
    
    print(f"\n[*] Scanning {len(ports)} ports on {host}...")
    tasks = [check_port(host, port, timeout) for port in ports]
    results = await asyncio.gather(*tasks)
    open_ports = [port for port in results if port is not None]
    
    print(f"[‚úì] Found {len(open_ports)} open ports: {sorted(open_ports)}")
    return sorted(open_ports)

# ============================================================================
# OWASP TOP 10 VULNERABILITY CHECKS
# ============================================================================

# OWASP A1: Injection Flaws (SQLi & Command Injection)
async def check_injection(session: aiohttp.ClientSession, url: str) -> Optional[Dict]:
    """Check for SQL Injection and Command Injection vulnerabilities"""
    payloads = [
        "' OR '1'='1",
        "' OR 1=1--",
        "admin' --",
        "1' UNION SELECT NULL--",
        "; DROP TABLE users--",
        "| whoami",
        "&& whoami",
        "` whoami `"
    ]
    
    try:
        for payload in payloads:
            try:
                async with session.get(f"{url}?id={payload}", timeout=5) as r:
                    text = await r.text()
                    # Look for SQL errors or command output
                    if any(err in text.lower() for err in ["sql", "syntax", "error", "exception", "uid=", "gid="]):
                        logger.warning(f"Injection vulnerability found at {url} with payload: {payload}")
                        return {
                            "vuln": "Injection Flaws (SQLi/Command Injection)",
                            "severity": "Critical",
                            "score": SEVERITY_SCORES["Critical"],
                            "reference": "OWASP A1",
                            "payload": payload,
                            "evidence": {
                                "request": f"{url}?id={payload}",
                                "response_code": r.status,
                                "response_snippet": text[:300]
                            },
                            "remediation": "Use parameterized queries, input validation, and prepared statements. Never concatenate user input directly into SQL queries."
                        }
            except:
                continue
    except Exception as e:
        logger.error(f"Error in injection check: {str(e)}")
    
    return None

# OWASP A2: Broken Authentication
async def check_auth(session: aiohttp.ClientSession, url: str) -> Optional[Dict]:
    """Check for broken authentication mechanisms"""
    try:
        test_urls = [
            urljoin(url, "/login"),
            urljoin(url, "/admin"),
            urljoin(url, "/api/login"),
            urljoin(url, "/auth")
        ]
        
        for test_url in test_urls:
            try:
                async with session.get(test_url, timeout=5) as r:
                    text = await r.text()
                    if r.status == 200 and any(kw in text.lower() for kw in ["password", "login", "username"]):
                        logger.warning(f"Potential auth page at {test_url}")
                        return {
                            "vuln": "Broken Authentication",
                            "severity": "High",
                            "score": SEVERITY_SCORES["High"],
                            "reference": "OWASP A2",
                            "payload": None,
                            "evidence": {
                                "request": test_url,
                                "response_code": r.status,
                                "response_snippet": text[:300]
                            },
                            "remediation": "Implement MFA, secure password storage (bcrypt/Argon2), rate limiting, and session management best practices."
                        }
            except:
                continue
    except Exception as e:
        logger.error(f"Error in authentication check: {str(e)}")
    
    return None

# OWASP A3: Sensitive Data Exposure
async def check_sensitive_data(session: aiohttp.ClientSession, url: str) -> Optional[Dict]:
    """Check for sensitive data exposure"""
    try:
        parsed = urlparse(url)
        if not url.startswith("https://"):
            async with session.get(url, timeout=5, allow_redirects=False) as r:
                headers = str(r.headers)
                logger.warning(f"Non-HTTPS connection detected: {url}")
                return {
                    "vuln": "Sensitive Data Exposure (No HTTPS)",
                    "severity": "High",
                    "score": SEVERITY_SCORES["High"],
                    "reference": "OWASP A3",
                    "payload": None,
                    "evidence": {
                        "request": url,
                        "response_code": r.status,
                        "response_snippet": headers[:300]
                    },
                    "remediation": "Enforce HTTPS/TLS with strong ciphers (TLS 1.2+). Use HSTS headers and avoid transmitting sensitive data in plaintext."
                }
        
        # Check for insecure headers
        async with session.get(url, timeout=5) as r:
            headers = dict(r.headers)
            missing_headers = []
            
            if "Strict-Transport-Security" not in headers:
                missing_headers.append("HSTS")
            if "X-Content-Type-Options" not in headers:
                missing_headers.append("X-Content-Type-Options")
            if "X-Frame-Options" not in headers:
                missing_headers.append("X-Frame-Options")
            
            if missing_headers:
                logger.warning(f"Missing security headers at {url}: {missing_headers}")
                return {
                    "vuln": "Sensitive Data Exposure (Missing Headers)",
                    "severity": "Medium",
                    "score": SEVERITY_SCORES["Medium"],
                    "reference": "OWASP A3",
                    "payload": None,
                    "evidence": {
                        "request": url,
                        "response_code": r.status,
                        "missing_headers": missing_headers
                    },
                    "remediation": "Add security headers: Strict-Transport-Security, X-Content-Type-Options, X-Frame-Options, Content-Security-Policy."
                }
    except Exception as e:
        logger.error(f"Error in sensitive data check: {str(e)}")
    
    return None

# OWASP A4: XML External Entities (XXE)
async def check_xxe(session: aiohttp.ClientSession, url: str) -> Optional[Dict]:
    """Check for XXE vulnerabilities"""
    payloads = [
        """<?xml version="1.0"?>
<!DOCTYPE foo [<!ENTITY xxe SYSTEM "file:///etc/passwd">]>
<foo>&xxe;</foo>""",
        """<?xml version="1.0"?>
<!DOCTYPE foo [<!ENTITY xxe SYSTEM "file:///c:/windows/win.ini">]>
<foo>&xxe;</foo>""",
        """<?xml version="1.0"?>
<!DOCTYPE foo [<!ENTITY xxe SYSTEM "http://localhost/">]>
<foo>&xxe;</foo>"""
    ]
    
    try:
        for payload in payloads:
            try:
                async with session.post(url, data=payload, headers={"Content-Type": "application/xml"}, timeout=5) as r:
                    text = await r.text()
                    if any(indicator in text for indicator in ["root:", "/bin/", "[extensions]", "localhost"]):
                        logger.warning(f"XXE vulnerability detected at {url}")
                        return {
                            "vuln": "XML External Entities (XXE)",
                            "severity": "High",
                            "score": SEVERITY_SCORES["High"],
                            "reference": "OWASP A4",
                            "payload": payload,
                            "evidence": {
                                "request": url,
                                "response_code": r.status,
                                "response_snippet": text[:300]
                            },
                            "remediation": "Disable XXE processing in XML parsers. Use libraries with secure defaults. Validate and sanitize XML input."
                        }
            except:
                continue
    except Exception as e:
        logger.error(f"Error in XXE check: {str(e)}")
    
    return None

# OWASP A5: Broken Access Control
async def check_access_control(session: aiohttp.ClientSession, url: str) -> Optional[Dict]:
    """Check for broken access control"""
    test_paths = [
        "/admin",
        "/admin/dashboard",
        "/api/admin",
        "/user/1",
        "/user/2",
        "/settings",
        "/private"
    ]
    
    try:
        for path in test_paths:
            try:
                test_url = urljoin(url, path)
                async with session.get(test_url, timeout=5) as r:
                    text = await r.text()
                    if r.status == 200 and "unauthorized" not in text.lower() and "forbidden" not in text.lower():
                        logger.warning(f"Potential access control issue at {test_url}")
                        return {
                            "vuln": "Broken Access Control",
                            "severity": "High",
                            "score": SEVERITY_SCORES["High"],
                            "reference": "OWASP A5",
                            "payload": None,
                            "evidence": {
                                "request": test_url,
                                "response_code": r.status,
                                "response_snippet": text[:300]
                            },
                            "remediation": "Enforce authorization checks on every request. Use role-based access control (RBAC) and validate permissions server-side."
                        }
            except:
                continue
    except Exception as e:
        logger.error(f"Error in access control check: {str(e)}")
    
    return None

# OWASP A6: Security Misconfiguration
async def check_misconfig(session: aiohttp.ClientSession, url: str) -> Optional[Dict]:
    """Check for security misconfiguration"""
    try:
        async with session.get(url, timeout=5) as r:
            headers = dict(r.headers)
            server = headers.get("Server", "").lower()
            
            # Check for outdated/revealing server info
            if any(old in server for old in ["apache/2.2", "apache/2.0", "php/5", "php/4"]):
                logger.warning(f"Outdated server software detected: {server}")
                return {
                    "vuln": "Security Misconfiguration",
                    "severity": "Medium",
                    "score": SEVERITY_SCORES["Medium"],
                    "reference": "OWASP A6",
                    "payload": None,
                    "evidence": {
                        "request": url,
                        "response_code": r.status,
                        "server_version": server
                    },
                    "remediation": "Update to latest stable versions. Disable version banners. Remove unnecessary services and features."
                }
            
            # Check for default files
            dangerous_paths = ["/admin.php", "/backup.zip", "/.env", "/.git/config", "/wp-admin"]
            for path in dangerous_paths:
                try:
                    async with session.get(urljoin(url, path), timeout=3) as check_r:
                        if check_r.status != 404:
                            logger.warning(f"Dangerous path accessible: {path}")
                            return {
                                "vuln": "Security Misconfiguration",
                                "severity": "High",
                                "score": SEVERITY_SCORES["High"],
                                "reference": "OWASP A6",
                                "payload": None,
                                "evidence": {
                                    "request": urljoin(url, path),
                                    "response_code": check_r.status
                                },
                                "remediation": "Remove or protect sensitive files. Use .htaccess, firewall rules, or application-level access controls."
                            }
                except:
                    continue
    except Exception as e:
        logger.error(f"Error in misconfiguration check: {str(e)}")
    
    return None

# OWASP A7: Cross-Site Scripting (XSS)
async def check_xss(session: aiohttp.ClientSession, url: str) -> Optional[Dict]:
    """Check for XSS vulnerabilities"""
    payloads = [
        "<script>alert('XSS')</script>",
        "'\"><script>alert(String.fromCharCode(88,83,83))</script>",
        "<img src=x onerror=alert('XSS')>",
        "<svg onload=alert('XSS')>",
        "javascript:alert('XSS')",
        "<iframe src=\"javascript:alert('XSS')\"></iframe>"
    ]
    
    try:
        for payload in payloads:
            try:
                async with session.get(f"{url}?q={payload}", timeout=5) as r:
                    text = await r.text()
                    if payload in text:
                        logger.warning(f"Reflected XSS vulnerability detected at {url}")
                        return {
                            "vuln": "Cross-Site Scripting (XSS)",
                            "severity": "High",
                            "score": SEVERITY_SCORES["High"],
                            "reference": "OWASP A7",
                            "payload": payload,
                            "evidence": {
                                "request": f"{url}?q={payload}",
                                "response_code": r.status,
                                "response_snippet": text[:300]
                            },
                            "remediation": "Implement input validation, output encoding, and Content-Security-Policy headers. Use templating engines with auto-escaping."
                        }
            except:
                continue
    except Exception as e:
        logger.error(f"Error in XSS check: {str(e)}")
    
    return None

# OWASP A8: Insecure Deserialization
async def check_deserialization(session: aiohttp.ClientSession, url: str) -> Optional[Dict]:
    """Check for insecure deserialization"""
    payloads = [
        '{"user":"admin","role":"admin"}',
        '{"isAdmin":true}',
        '{"privilegeLevel":999}'
    ]
    
    try:
        for payload in payloads:
            try:
                async with session.post(url, data=payload, headers={"Content-Type": "application/json"}, timeout=5) as r:
                    text = await r.text()
                    if any(keyword in text.lower() for keyword in ["admin", "privilege", "success"]):
                        logger.warning(f"Potential deserialization issue at {url}")
                        return {
                            "vuln": "Insecure Deserialization",
                            "severity": "High",
                            "score": SEVERITY_SCORES["High"],
                            "reference": "OWASP A8",
                            "payload": payload,
                            "evidence": {
                                "request": url,
                                "response_code": r.status,
                                "response_snippet": text[:300]
                            },
                            "remediation": "Avoid deserializing untrusted data. Use safe formats like JSON. Implement object input validation and filtering."
                        }
            except:
                continue
    except Exception as e:
        logger.error(f"Error in deserialization check: {str(e)}")
    
    return None

# OWASP A9: Using Components with Known Vulnerabilities
async def check_components(session: aiohttp.ClientSession, url: str) -> Optional[Dict]:
    """Check for outdated/vulnerable components"""
    try:
        async with session.get(url, timeout=5) as r:
            headers = dict(r.headers)
            text = await r.text()
            
            # Check headers
            server = headers.get("Server", "").lower()
            vulnerable_versions = {
                "apache/2.2": "Critical",
                "apache/2.0": "Critical",
                "php/5.2": "Critical",
                "php/5.3": "High",
                "php/5.4": "High",
                "jboss": "High",
                "tomcat/5": "High"
            }
            
            for version, severity in vulnerable_versions.items():
                if version in server:
                    logger.warning(f"Vulnerable component detected: {version}")
                    return {
                        "vuln": "Using Components with Known Vulnerabilities",
                        "severity": severity,
                        "score": SEVERITY_SCORES[severity],
                        "reference": "OWASP A9",
                        "payload": None,
                        "evidence": {
                            "request": url,
                            "response_code": r.status,
                            "vulnerable_component": version
                        },
                        "remediation": f"Update {version} to the latest patched version. Implement vulnerability scanning in CI/CD pipeline."
                    }
            
            # Check for common vulnerable library patterns
            if "jquery" in text.lower() or "bootstrap" in text.lower():
                logger.info(f"Client-side libraries detected at {url}")
    except Exception as e:
        logger.error(f"Error in components check: {str(e)}")
    
    return None

# OWASP A10: Insufficient Logging & Monitoring
async def check_logging(session: aiohttp.ClientSession, url: str) -> Optional[Dict]:
    """Check for insufficient logging and monitoring"""
    try:
        # Try to access invalid pages
        invalid_paths = ["/invalidpage12345", "/nonexistent.php", "/admin_backup"]
        
        for path in invalid_paths:
            try:
                test_url = urljoin(url, path)
                async with session.get(test_url, timeout=5) as r:
                    text = await r.text()
                    # If 404 page has no useful error info, logging might be insufficient
                    if r.status == 404 and len(text) < 500:
                        logger.warning(f"Minimal error information at {test_url}")
                        return {
                            "vuln": "Insufficient Logging & Monitoring",
                            "severity": "Medium",
                            "score": SEVERITY_SCORES["Medium"],
                            "reference": "OWASP A10",
                            "payload": None,
                            "evidence": {
                                "request": test_url,
                                "response_code": r.status,
                                "response_length": len(text)
                            },
                            "remediation": "Implement comprehensive logging for security events. Monitor access logs, errors, and failed authentication attempts."
                        }
            except:
                continue
    except Exception as e:
        logger.error(f"Error in logging check: {str(e)}")
    
    return None

# ============================================================================
# SCAN ORCHESTRATION
# ============================================================================

async def run_vulnerability_checks(url: str) -> List[Dict]:
    """Run all vulnerability checks"""
    checks = [
        ("A1: Injection Flaws", check_injection),
        ("A2: Broken Authentication", check_auth),
        ("A3: Sensitive Data Exposure", check_sensitive_data),
        ("A4: XXE", check_xxe),
        ("A5: Broken Access Control", check_access_control),
        ("A6: Security Misconfiguration", check_misconfig),
        ("A7: Cross-Site Scripting (XSS)", check_xss),
        ("A8: Insecure Deserialization", check_deserialization),
        ("A9: Vulnerable Components", check_components),
        ("A10: Insufficient Logging", check_logging)
    ]
    
    vulnerabilities = []
    total_checks = len(checks)
    
    async with aiohttp.ClientSession() as session:
        for idx, (name, check_func) in enumerate(checks):
            progress = ((idx + 1) / total_checks) * 100
            print(f"\n[*] Progress: {progress:.0f}% ({idx + 1}/{total_checks} checks)")
            print(f"    Running: {name}...")
            
            try:
                result = await check_func(session, url)
                if result:
                    vulnerabilities.append(result)
                    print(f"    [!] VULNERABILITY FOUND: {result['vuln']} ({result['severity']})")
                else:
                    print(f"    [‚úì] No vulnerability detected")
            except Exception as e:
                logger.error(f"Error in {name}: {str(e)}")
                print(f"    [‚úó] Error during check: {str(e)}")
            
            await asyncio.sleep(0.5)  # Rate limiting
    
    return vulnerabilities

# ============================================================================
# REPORTING
# ============================================================================

def generate_json_report(target: str, open_ports: List[int], vulnerabilities: List[Dict], scan_time: float) -> str:
    """Generate JSON report"""
    report = {
        "scan_metadata": {
            "timestamp": datetime.now().isoformat(),
            "target": target,
            "scan_duration_seconds": round(scan_time, 2)
        },
        "port_scan": {
            "total_scanned": len(COMMON_PORTS),
            "open_ports": open_ports,
            "open_count": len(open_ports)
        },
        "vulnerability_scan": {
            "total_vulnerabilities": len(vulnerabilities),
            "critical_count": len([v for v in vulnerabilities if v["severity"] == "Critical"]),
            "high_count": len([v for v in vulnerabilities if v["severity"] == "High"]),
            "medium_count": len([v for v in vulnerabilities if v["severity"] == "Medium"]),
            "low_count": len([v for v in vulnerabilities if v["severity"] == "Low"]),
            "vulnerabilities": vulnerabilities
        },
        "risk_score": round(sum(v["score"] for v in vulnerabilities) / len(vulnerabilities), 2) if vulnerabilities else 0
    }
    
    return json.dumps(report, indent=2)

def generate_html_report(target: str, open_ports: List[int], vulnerabilities: List[Dict], scan_time: float) -> str:
    """Generate HTML report with color-coding and styling"""
    
    severity_colors = {
        "Critical": "#d32f2f",
        "High": "#f57c00",
        "Medium": "#fbc02d",
        "Low": "#388e3c",
        "Info": "#1976d2"
    }
    
    vuln_rows = ""
    for idx, vuln in enumerate(vulnerabilities, 1):
        color = severity_colors.get(vuln["severity"], "#999")
        vuln_rows += f"""
        <tr>
            <td>{idx}</td>
            <td>{escape(vuln['vuln'])}</td>
            <td style="background-color: {color}; color: white; font-weight: bold;">{vuln['severity']}</td>
            <td>{vuln['reference']}</td>
            <td>{vuln['score']}</td>
            <td><code>{escape(str(vuln['payload'])[:100]) if vuln['payload'] else 'N/A'}</code></td>
            <td style="max-width: 300px; overflow-y: auto;"><code>{escape(str(vuln['evidence'])[:200])}</code></td>
            <td>{escape(vuln['remediation'][:150])}</td>
        </tr>
        """
    
    port_rows = ""
    for port in open_ports[:50]:  # Limit to 50 for readability
        port_rows += f"<tr><td>{port}</td></tr>"
    
    html = f"""
    <!DOCTYPE html>
    <html lang="en">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>OWASP Vulnerability Scan Report</title>
        <style>
            * {{ margin: 0; padding: 0; box-sizing: border-box; }}
            body {{ font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; background: #f5f5f5; padding: 20px; }}
            .container {{ max-width: 1400px; margin: 0 auto; background: white; padding: 30px; border-radius: 8px; box-shadow: 0 2px 8px rgba(0,0,0,0.1); }}
            h1 {{ color: #d32f2f; border-bottom: 3px solid #d32f2f; padding-bottom: 10px; margin-bottom: 20px; }}
            h2 {{ color: #1976d2; margin-top: 30px; margin-bottom: 15px; border-left: 4px solid #1976d2; padding-left: 10px; }}
            .summary {{ display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 15px; margin-bottom: 30px; }}
            .card {{ background: #f9f9f9; padding: 15px; border-radius: 6px; border-left: 4px solid; }}
            .card-critical {{ border-left-color: #d32f2f; }}
            .card-high {{ border-left-color: #f57c00; }}
            .card-medium {{ border-left-color: #fbc02d; }}
            .card-low {{ border-left-color: #388e3c; }}
            .card strong {{ display: block; font-size: 24px; color: #333; }}
            .card span {{ color: #666; font-size: 12px; }}
            table {{ width: 100%; border-collapse: collapse; margin-top: 15px; font-size: 13px; }}
            th {{ background: #1976d2; color: white; padding: 12px; text-align: left; font-weight: 600; }}
            td {{ padding: 10px; border-bottom: 1px solid #ddd; }}
            tr:hover {{ background: #f5f5f5; }}
            code {{ background: #f4f4f4; padding: 2px 6px; border-radius: 3px; font-family: 'Courier New', monospace; word-break: break-all; }}
            .footer {{ margin-top: 40px; padding-top: 20px; border-top: 1px solid #ddd; text-align: center; color: #666; font-size: 12px; }}
            .severity-badge {{ padding: 4px 8px; border-radius: 4px; color: white; font-weight: bold; font-size: 12px; }}
            .critical {{ background: #d32f2f; }}
            .high {{ background: #f57c00; }}
            .medium {{ background: #fbc02d; color: #333; }}
            .low {{ background: #388e3c; }}
        </style>
    </head>
    <body>
        <div class="container">
            <h1>üîí OWASP Top 10 Vulnerability Scan Report</h1>
            
            <div style="background: #e3f2fd; padding: 15px; border-radius: 4px; margin-bottom: 20px; border-left: 4px solid #1976d2;">
                <strong>üìã Scan Details:</strong><br>
                Target: <code>{escape(target)}</code><br>
                Scan Time: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}<br>
                Duration: {round(scan_time, 2)}s
            </div>
            
            <h2>üìä Summary</h2>
            <div class="summary">
                <div class="card card-critical">
                    <strong>{len([v for v in vulnerabilities if v['severity'] == 'Critical'])}</strong>
                    <span>Critical Issues</span>
                </div>
                <div class="card card-high">
                    <strong>{len([v for v in vulnerabilities if v['severity'] == 'High'])}</strong>
                    <span>High Issues</span>
                </div>
                <div class="card card-medium">
                    <strong>{len([v for v in vulnerabilities if v['severity'] == 'Medium'])}</strong>
                    <span>Medium Issues</span>
                </div>
                <div class="card card-low">
                    <strong>{len([v for v in vulnerabilities if v['severity'] == 'Low'])}</strong>
                    <span>Low Issues</span>
                </div>
                <div class="card" style="border-left-color: #666;">
                    <strong>{len(vulnerabilities)}</strong>
                    <span>Total Vulnerabilities</span>
                </div>
                <div class="card" style="border-left-color: #666;">
                    <strong>{len(open_ports)}</strong>
                    <span>Open Ports</span>
                </div>
            </div>
            
            <h2>üåê Open Ports ({len(open_ports)})</h2>
            <table>
                <thead><tr><th>Port Number</th></tr></thead>
                <tbody>
                    {port_rows if port_rows else '<tr><td>No open ports found</td></tr>'}
                </tbody>
            </table>
            
            <h2>üö® Vulnerabilities ({len(vulnerabilities)})</h2>
            <table>
                <thead>
                    <tr>
                        <th>#</th>
                        <th>Vulnerability</th>
                        <th>Severity</th>
                        <th>Reference</th>
                        <th>Score</th>
                        <th>Payload</th>
                        <th>Evidence</th>
                        <th>Remediation</th>
                    </tr>
                </thead>
                <tbody>
                    {vuln_rows if vuln_rows else '<tr><td colspan="8">No vulnerabilities detected ‚úì</td></tr>'}
                </tbody>
            </table>
            
            <h2>üìù Remediation Guide</h2>
            <div style="background: #f5f5f5; padding: 15px; border-radius: 4px;">
                <ol>
                    <li><strong>Critical Issues:</strong> Fix immediately. These pose severe security risks.</li>
                    <li><strong>High Issues:</strong> Fix within 1-2 weeks. Implement security patches and updates.</li>
                    <li><strong>Medium Issues:</strong> Fix within 1 month. Add security controls and best practices.</li>
                    <li><strong>Low Issues:</strong> Schedule for next maintenance cycle.</li>
                </ol>
            </div>
            
            <div class="footer">
                <p>Generated by OWASP Vulnerability Scanner v2.0 | Authorized Security Assessment Tool</p>
                <p>‚ö†Ô∏è This report contains sensitive security information. Handle with care.</p>
            </div>
        </div>
    </body>
    </html>
    """
    
    return html

# ============================================================================
# MAIN EXECUTION
# ============================================================================

async def main():
    """Main execution flow"""
    print("\n" + "="*80)
    print("OWASP TOP 10 VULNERABILITY SCANNER v2.0".center(80))
    print("="*80)
    
    # Show ethical notice
    show_ethical_notice()
    
    # Get target from user
    target = input("\n[?] Enter target IP or domain (e.g., 192.168.1.1 or example.com): ").strip()
    if not target:
        print("‚ùå Target required. Exiting.")
        sys.exit(1)
    
    # Validate and normalize target
    if not target.startswith(("http://", "https://")):
        target = f"http://{target}"
    
    # Resolve hostname to IP
    parsed = urlparse(target)
    hostname = parsed.netloc or parsed.path
    try:
        ip = socket.gethostbyname(hostname)
        print(f"[‚úì] Resolved {hostname} ‚Üí {ip}")
    except socket.gaierror:
        print(f"‚ö†Ô∏è  Could not resolve {hostname}. Proceeding with URL-based scanning.")
        ip = hostname
    
    print(f"\n[*] Starting scan on {target}...\n")
    start_time = time.time()
    
    # Port scanning
    try:
        open_ports = await scan_ports(ip, COMMON_PORTS, timeout=2)
    except Exception as e:
        print(f"‚ö†Ô∏è  Port scanning failed: {str(e)}")
        open_ports = []
    
    # Vulnerability scanning
    print("\n[*] Starting OWASP Top 10 vulnerability assessment...")
    vulnerabilities = await run_vulnerability_checks(target)
    
    scan_time = time.time() - start_time
    
    # Generate reports
    print("\n[*] Generating reports...")
    
    json_report = generate_json_report(target, open_ports, vulnerabilities, scan_time)
    with open("scan_report.json", "w") as f:
        f.write(json_report)
    print("‚úì JSON report saved: scan_report.json")
    
    html_report = generate_html_report(target, open_ports, vulnerabilities, scan_time)
    with open("scan_report.html", "w") as f:
        f.write(html_report)
    print("‚úì HTML report saved: scan_report.html")
    
    # Console summary
    print("\n" + "="*80)
    print("SCAN SUMMARY".center(80))
    print("="*80)
    print(f"Target: {target}")
    print(f"Scan Duration: {scan_time:.2f} seconds")
    print(f"Open Ports: {len(open_ports)} {sorted(open_ports) if open_ports else '(none)'}")
    print(f"\nVulnerabilities Found: {len(vulnerabilities)}")
    print(f"  ‚îú‚îÄ Critical: {len([v for v in vulnerabilities if v['severity'] == 'Critical'])}")
    print(f"  ‚îú‚îÄ High: {len([v for v in vulnerabilities if v['severity'] == 'High'])}")
    print(f"  ‚îú‚îÄ Medium: {len([v for v in vulnerabilities if v['severity'] == 'Medium'])}")
    print(f"  ‚îî‚îÄ Low: {len([v for v in vulnerabilities if v['severity'] == 'Low'])}")
    
    if vulnerabilities:
        print(f"\nTop Vulnerabilities:")
        for vuln in sorted(vulnerabilities, key=lambda x: x['score'], reverse=True)[:5]:
            print(f"  ‚Ä¢ {vuln['vuln']} ({vuln['severity']}) - {vuln['reference']}")
    else:
        print("\n‚úì No vulnerabilities detected!")
    
    print("\n" + "="*80)
    print("üìÑ Reports available: scan_report.json, scan_report.html, responses.log")
    print("="*80 + "\n")

if __name__ == "__main__":
    try:
        asyncio.run(main())
    except KeyboardInterrupt:
        print("\n\n‚ùå Scan interrupted by user.")
        sys.exit(0)
    except Exception as e:
        logger.error(f"Fatal error: {str(e)}")
        print(f"\n‚ùå Fatal error: {str(e)}")
        sys.exit(1)
