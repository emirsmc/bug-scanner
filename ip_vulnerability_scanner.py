#!/usr/bin/env python3
"""
Professional Ethical Vulnerability Scanner - Enhanced Edition
Inspired by Nmap, Nikto, XSStrike, sqlmap (detection logic only), and Burp Suite.
Author: Security Professional
Version: 4.0 (Production-Ready with Enhanced Detection)
"""

import asyncio
import aiohttp
import argparse
import logging
import json
import sys
import ssl
import socket
import subprocess
import shutil
import re
import hashlib
import time
from datetime import datetime, timezone
from dataclasses import dataclass, field, asdict
from typing import List, Dict, Optional, Any, Set, Tuple
from urllib.parse import urlparse, urljoin, quote
from asyncio import Semaphore, TimeoutError, Queue
from collections import defaultdict
import html  # For sanitizing snippets
import random

# ============================================================================
# CONFIGURATION & CONSTANTS
# ============================================================================

VERSION = "4.0"
LOG_FILE = "scanner_audit.log"
REQUIRED_CONSENT = "I HAVE EXPLICIT AUTHORIZATION"

# Common ports for scanning (Top 1000 reduced for performance)
COMMON_PORTS = [
    21, 22, 23, 25, 53, 80, 110, 111, 135, 139, 143, 443, 445, 993, 995, 1723,
    3306, 3389, 5900, 8080, 8443, 8888, 9092, 27017, 5432, 6379, 9200, 11211,
    5000, 5005, 8086, 8082, 8000, 8008, 8081, 8089, 9000, 9042, 27018, 27019,
    1433, 1521, 1830, 2082, 2083, 2086, 2087, 2095, 2096, 2483, 2484, 3128,
    3333, 4443, 4444, 5001, 5038, 5433, 5800, 6082, 7000, 7001, 7002, 7071,
    7170, 7474, 7547, 7777, 7778, 8001, 8002, 8003, 8004, 8005, 8006, 8007,
    8009, 8010, 8020, 8042, 8045, 8083, 8084, 8085, 8087, 8090, 8091, 8092,
    8093, 8094, 8095, 8096, 8097, 8098, 8099, 8100, 8181, 8200, 8222, 8243,
    8280, 8281, 8291, 8300, 8333, 8383, 8384, 8403, 8404, 8444, 8445, 8446,
    8447, 8448, 8449, 8450, 8484, 8500, 8530, 8531, 8593, 8649, 8834, 8880,
    8881, 8882, 8883, 8884, 8885, 8886, 8887, 8888, 8889, 8890, 8891, 8892,
    8893, 8894, 8895, 8896, 8897, 8898, 8899, 8983, 9001, 9002, 9003, 9004,
    9005, 9006, 9007, 9008, 9009, 9010, 9043, 9050, 9051, 9080, 9081, 9090,
    9091, 9092, 9093, 9094, 9095, 9096, 9097, 9098, 9099, 9100, 9101, 9102,
    9103, 9104, 9105, 9106, 9107, 9108, 9109, 9110, 9200, 9201, 9202, 9203,
    9204, 9205, 9206, 9207, 9208, 9209, 9210, 9292, 9293, 9294, 9295, 9296,
    9297, 9298, 9299, 9300, 9418, 9443, 9444, 9445, 9446, 9447, 9448, 9449,
    9450, 9500, 9501, 9502, 9503, 9504, 9505, 9506, 9507, 9508, 9509, 9510,
    9600, 9700, 9800, 9900, 9981, 9988, 9999, 10000, 10001, 10002, 10003,
    10004, 10005, 10006, 10007, 10008, 10009, 10010, 10050, 10051, 10080,
    10180, 10243, 10443, 10666, 11000, 11111, 11211, 11443, 11444, 12345,
    12346, 12347, 12348, 12349, 12350, 12777, 13000, 13001, 13002, 13003,
    13004, 13005, 13006, 13007, 13008, 13009, 13010, 14000, 14147, 14441,
    14442, 14443, 14444, 14445, 14446, 14447, 14448, 14449, 14450, 14500,
    15000, 15001, 15002, 15003, 15004, 15005, 15006, 15007, 15008, 15009,
    15010, 15555, 16000, 16001, 16002, 16003, 16004, 16005, 16006, 16007,
    16008, 16009, 16010, 16379, 16555, 17000, 17001, 17002, 17003, 17004,
    17005, 17006, 17007, 17008, 17009, 17010, 18000, 18001, 18002, 18003,
    18004, 18005, 18006, 18007, 18008, 18009, 18010, 18101, 18102, 18103,
    18104, 18105, 18106, 18107, 18108, 18109, 18110, 18881, 19000, 19001,
    19002, 19003, 19004, 19005, 19006, 19007, 19008, 19009, 19010, 19101,
    19102, 19103, 19104, 19105, 19106, 19107, 19108, 19109, 19110, 19292,
    19333, 19444, 19555, 19666, 19777, 19888, 19999, 20000
]

# Sensitive paths for directory enumeration
SENSITIVE_PATHS = [
    "/admin", "/login", "/backup", "/.git", "/.env", "/wp-admin",
    "/phpinfo.php", "/test.php", "/.aws/credentials", "/server-status",
    "/.svn", "/.htaccess", "/config.php", "/db_backup.sql", "/wp-config.php",
    "/config.inc.php", "/configuration.php", "/.bash_history", "/.mysql_history",
    "/.ssh/id_rsa", "/.ssh/authorized_keys", "/.npmrc", "/.yarnrc",
    "/composer.json", "/package.json", "/web.config", "/.htpasswd",
    "/.git/config", "/.git/HEAD", "/.git/index", "/.svn/entries",
    "/.svn/wc.db", "/.DS_Store", "/Thumbs.db", "/crossdomain.xml",
    "/clientaccesspolicy.xml", "/sitemap.xml", "/robots.txt", "/README.md",
    "/CHANGELOG.md", "/LICENSE", "/COPYING", "/INSTALL", "/UPGRADE",
    "/api/swagger.json", "/api/docs", "/graphql", "/graphiql",
    "/actuator/health", "/actuator/info", "/actuator/env",
    "/console", "/h2-console", "/druid/index.html", "/zabbix",
    "/phpMyAdmin", "/phpmyadmin", "/pma", "/adminer", "/mysql-admin"
]

# Security headers to check with detailed descriptions
SECURITY_HEADERS = {
    "Strict-Transport-Security": {
        "description": "HSTS enforces HTTPS connections, preventing protocol downgrade attacks.",
        "remediation": "Add 'Strict-Transport-Security: max-age=31536000; includeSubDomains' header.",
        "severity": "Medium"
    },
    "Content-Security-Policy": {
        "description": "CSP mitigates XSS and data injection attacks by controlling resource loading.",
        "remediation": "Implement a Content-Security-Policy header with appropriate directives.",
        "severity": "High"
    },
    "X-Content-Type-Options": {
        "description": "Prevents MIME type sniffing, reducing exposure to drive-by download attacks.",
        "remediation": "Add 'X-Content-Type-Options: nosniff' header.",
        "severity": "Low"
    },
    "X-Frame-Options": {
        "description": "Protects against clickjacking attacks by controlling iframe embedding.",
        "remediation": "Add 'X-Frame-Options: DENY' or 'SAMEORIGIN' header.",
        "severity": "Medium"
    },
    "X-XSS-Protection": {
        "description": "Enables browser XSS filtering (legacy, use CSP instead).",
        "remediation": "Add 'X-XSS-Protection: 1; mode=block' header.",
        "severity": "Low"
    },
    "Referrer-Policy": {
        "description": "Controls how much referrer information is sent with requests.",
        "remediation": "Add 'Referrer-Policy: strict-origin-when-cross-origin' header.",
        "severity": "Low"
    },
    "Permissions-Policy": {
        "description": "Controls browser features and APIs that can be used.",
        "remediation": "Implement a Permissions-Policy header to restrict feature access.",
        "severity": "Low"
    },
    "Cache-Control": {
        "description": "Prevents sensitive information from being cached.",
        "remediation": "Add 'Cache-Control: no-store, no-cache, must-revalidate' for sensitive pages.",
        "severity": "Medium"
    }
}

# SQL Injection error patterns with weights for confidence scoring
SQL_ERROR_PATTERNS = [
    {"pattern": r"sql.*syntax.*error", "weight": 0.9, "type": "syntax"},
    {"pattern": r"unclosed.*quotation mark", "weight": 0.9, "type": "syntax"},
    {"pattern": r"mysql_fetch", "weight": 0.8, "type": "function"},
    {"pattern": r"ora-[0-9]{5}", "weight": 0.9, "type": "oracle"},
    {"pattern": r"postgresql.*error", "weight": 0.9, "type": "postgresql"},
    {"pattern": r"mssql.*error", "weight": 0.9, "type": "mssql"},
    {"pattern": r"sqlite.*error", "weight": 0.9, "type": "sqlite"},
    {"pattern": r"odbc.*driver", "weight": 0.8, "type": "odbc"},
    {"pattern": r"division by zero", "weight": 0.7, "type": "math"},
    {"pattern": r"unexpected.*end of file", "weight": 0.6, "type": "parse"},
    {"pattern": r"warning:.*mysql", "weight": 0.7, "type": "warning"},
    {"pattern": r"supplied argument is not a valid MySQL", "weight": 0.8, "type": "argument"}
]

# Boolean-based SQL injection test payloads
BOOLEAN_SQL_PAYLOADS = [
    {"payload": "' AND '1'='1", "true_condition": True},
    {"payload": "' AND '1'='2", "true_condition": False},
    {"payload": "' OR '1'='1'--", "true_condition": True},
    {"payload": "' OR '1'='2'--", "true_condition": False},
    {"payload": "1 AND 1=1", "true_condition": True},
    {"payload": "1 AND 1=2", "true_condition": False},
    {"payload": "1' AND '1' LIKE '1", "true_condition": True},
    {"payload": "1' AND '1' LIKE '2", "true_condition": False}
]

# Time-based SQL injection payloads (safe, with delays)
TIME_SQL_PAYLOADS = [
    {"payload": "'; WAITFOR DELAY '00:00:02'--", "delay": 2, "type": "mssql"},
    {"payload": "' OR SLEEP(2)--", "delay": 2, "type": "mysql"},
    {"payload": "'; SELECT pg_sleep(2)--", "delay": 2, "type": "postgresql"},
    {"payload": "' AND SLEEP(2) AND '1'='1", "delay": 2, "type": "mysql"}
]

# XSS test payloads with context detection
XSS_PAYLOADS = [
    {"payload": "<script>alert(1)</script>", "context": "html", "encoding": "none"},
    {"payload": "<img src=x onerror=alert(1)>", "context": "html", "encoding": "none"},
    {"payload": "javascript:alert(1)", "context": "url", "encoding": "none"},
    {"payload": "\"><script>alert(1)</script>", "context": "attribute", "encoding": "none"},
    {"payload": "';alert(1);//", "context": "script", "encoding": "none"},
    {"payload": "</script><script>alert(1)</script>", "context": "script", "encoding": "none"},
    {"payload": "<ScRiPt>alert(1)</ScRiPt>", "context": "html", "encoding": "case"},
    {"payload": "%3Cscript%3Ealert(1)%3C%2Fscript%3E", "context": "url", "encoding": "url"},
    {"payload": "&#x3C;&#x73;&#x63;&#x72;&#x69;&#x70;&#x74;&#x3E;", "context": "html", "encoding": "html"},
    {"payload": "\\x3Cscript\\x3Ealert(1)\\x3C/script\\x3E", "context": "js", "encoding": "unicode"}
]

# WAF detection signatures
WAF_SIGNATURES = {
    "Cloudflare": ["cloudflare-nginx", "__cfduid", "cf-ray"],
    "AWS WAF": ["x-amzn-RequestId", "x-amz-cf-id", "AWSALB"],
    "ModSecurity": ["mod_security", "NOYB", "This error was generated by Mod_Security"],
    "F5 BIG-IP": ["BigIP", "x-wa-rewrite", "x-application-context"],
    "Akamai": ["akamai", "x-akamai-"],
    "Sucuri": ["sucuri", "x-sucuri-id", "x-sucuri-cache"],
    "Barracuda": ["barracuda", "x-bfw-"],
    "Citrix": ["x-citrix-ns", "x-nitro"],
    "Imperva": ["x-iinfo", "incapsula"],
    "Radware": ["x-cnection", "rdwr"],
    "Fortinet": ["FortiWeb", "x-forti"],
    "Palo Alto": ["PAN-OS", "x-pan"],
    "Wordfence": ["wordfence"],
    "StackPath": ["stackpath"]
}

# Service fingerprinting patterns
SERVICE_PATTERNS = {
    "http": [b"HTTP/", b"<html", b"<!DOCTYPE"],
    "ssh": [b"SSH-", b"OpenSSH"],
    "ftp": [b"220", b"FTP"],
    "smtp": [b"220", b"SMTP", b"ESMTP"],
    "mysql": [b"mysql", b"MariaDB"],
    "postgresql": [b"PostgreSQL"],
    "redis": [b"+OK", b"-ERR"],
    "mongodb": [b"mongodb"],
    "elasticsearch": [b"elasticsearch"],
    "docker": [b"Docker"],
    "kubernetes": [b"kube"],
    "jenkins": [b"Jenkins"],
    "git": [b"git", b"smart http"],
    "svn": [b"svn"],
    "ntp": [b"NTP"],
    "dns": [b"DNS"],
    "dhcp": [b"DHCP"]
}

# CVE patterns for service version matching
CVE_PATTERNS = {
    "apache": {
        "2.4.49": ["CVE-2021-41773", "CVE-2021-42013"],
        "2.4.50": ["CVE-2021-42013"],
        "2.2.15": ["CVE-2010-1452"]
    },
    "nginx": {
        "1.20.0": ["CVE-2021-23017"],
        "1.18.0": ["CVE-2021-23017"]
    },
    "openssh": {
        "7.2p2": ["CVE-2016-6210"],
        "7.4": ["CVE-2017-15906"]
    }
}

# ============================================================================
# DATA CLASSES
# ============================================================================

@dataclass
class ScanTarget:
    """Represents the target after resolution."""
    original: str
    resolved_host: str
    protocol: str  # 'http' or 'https'
    port: int
    base_url: str
    redirect_chain: List[str] = field(default_factory=list)
    waf: Optional[str] = None
    technologies: List[str] = field(default_factory=list)

@dataclass
class PortInfo:
    """Information about an open port."""
    port: int
    service: str = "unknown"
    version: str = ""
    banner: str = ""
    state: str = "open"
    cves: List[str] = field(default_factory=list)
    confidence: float = 0.5

@dataclass
class Vulnerability:
    """Represents a detected vulnerability."""
    name: str
    severity: str  # Critical, High, Medium, Low, Info
    endpoint: str
    method: str = "GET"
    payload: Optional[str] = None
    status_code: Optional[int] = None
    response_snippet: str = ""
    description: str = ""
    confidence: str = "Medium"  # High, Medium, Low
    confidence_score: float = 0.7
    remediation: str = ""
    evidence: Dict[str, Any] = field(default_factory=dict)
    cve: Optional[str] = None

@dataclass
class ScanResult:
    """Aggregated scan results."""
    target: ScanTarget
    start_time: datetime
    end_time: Optional[datetime] = None
    open_ports: List[PortInfo] = field(default_factory=list)
    vulnerabilities: List[Vulnerability] = field(default_factory=list)
    total_requests: int = 0
    external_tool_results: Dict[str, Any] = field(default_factory=dict)
    subdomains: List[str] = field(default_factory=list)

# ============================================================================
# LOGGING SETUP
# ============================================================================

logger = logging.getLogger("VulnScanner")
logger.setLevel(logging.INFO)
file_handler = logging.FileHandler(LOG_FILE)
file_handler.setFormatter(logging.Formatter('%(asctime)s - %(levelname)s - %(message)s'))
console_handler = logging.StreamHandler()
console_handler.setFormatter(logging.Formatter('%(levelname)s: %(message)s'))
logger.addHandler(file_handler)
logger.addHandler(console_handler)

# ============================================================================
# SSL CONTEXT (Improved)
# ============================================================================

def create_ssl_context() -> ssl.SSLContext:
    """Create a secure SSL context with proper validation."""
    context = ssl.create_default_context()
    context.check_hostname = True
    context.verify_mode = ssl.CERT_REQUIRED
    # Set minimum TLS version to 1.2
    context.minimum_version = ssl.TLSVersion.TLSv1_2
    # Load default CA certificates
    context.load_default_certs()
    return context

# ============================================================================
# ETHICAL & LEGAL SAFEGUARDS
# ============================================================================

def get_user_consent() -> None:
    """Display legal warning and require explicit consent."""
    warning = f"""
    ╔══════════════════════════════════════════════════════════════════════════╗
    ║                         LEGAL WARNING & DISCLAIMER                       ║
    ╠══════════════════════════════════════════════════════════════════════════╣
    ║  This tool is for AUTHORIZED SECURITY TESTING ONLY.                      ║
    ║                                                                           ║
    ║  • You must have EXPLICIT WRITTEN PERMISSION from the target owner.      ║
    ║  • Unauthorized scanning is ILLEGAL and may violate:                     ║
    ║    - Computer Fraud and Abuse Act (CFAA) and similar laws worldwide.     ║
    ║    - GDPR, Privacy, and Telecommunications regulations.                  ║
    ║  • Misuse can lead to criminal prosecution and civil liability.          ║
    ║                                                                           ║
    ║  By proceeding, you assume FULL RESPONSIBILITY for your actions.         ║
    ║  The author and contributors disclaim all liability for misuse or damage.║
    ╚══════════════════════════════════════════════════════════════════════════╝
    """
    print(warning)
    print("\nTo confirm your authorization, type the exact phrase:")
    consent = input(f'>>> "{REQUIRED_CONSENT}": ').strip()

    if consent != REQUIRED_CONSENT:
        logger.error("Authorization not provided. Exiting.")
        sys.exit(1)

    logger.info(f"Authorization confirmed by user: {REQUIRED_CONSENT}")
    print("✓ Authorization accepted. Starting scanner...\n")

# ============================================================================
# TARGET RESOLVER (Enhanced with WAF detection)
# ============================================================================

class TargetResolver:
    """Resolves and normalizes the target input with enhanced detection."""

    @staticmethod
    async def resolve(target_str: str, timeout: int = 5) -> Optional[ScanTarget]:
        """
        Resolve target, detect protocol, follow redirects, and determine final URL.
        Also detects WAF and technologies.
        """
        parsed = urlparse(target_str)
        # If no scheme, assume http and try to upgrade to https
        if not parsed.scheme:
            target_str = f"http://{target_str}"
            parsed = urlparse(target_str)

        host = parsed.netloc or parsed.path
        initial_protocol = parsed.scheme.lower()
        port = TargetResolver._get_port(parsed.port, initial_protocol)

        # Try HTTPS first if not explicitly http
        protocols_to_try = ["https", "http"] if initial_protocol != "http" else ["http", "https"]
        
        # Create proper SSL context
        ssl_context = create_ssl_context()
        
        # Configure connector with proper SSL
        connector = aiohttp.TCPConnector(ssl=ssl_context)

        async with aiohttp.ClientSession(connector=connector) as session:
            for proto in protocols_to_try:
                test_url = f"{proto}://{host}"
                if port not in [80, 443]:
                    test_url = f"{proto}://{host}:{port}"

                try:
                    async with session.get(test_url, timeout=timeout, allow_redirects=True) as resp:
                        final_url = str(resp.url)
                        final_parsed = urlparse(final_url)
                        redirect_chain = [str(h.url) for h in resp.history] + [final_url]

                        # Determine final protocol and port
                        final_protocol = final_parsed.scheme
                        final_port = final_parsed.port or (443 if final_protocol == "https" else 80)
                        final_host = final_parsed.netloc.split(':')[0]

                        # Detect WAF
                        waf = await TargetResolver._detect_waf(resp)
                        
                        # Detect technologies
                        technologies = await TargetResolver._detect_technologies(resp)

                        return ScanTarget(
                            original=target_str,
                            resolved_host=final_host,
                            protocol=final_protocol,
                            port=final_port,
                            base_url=f"{final_protocol}://{final_host}:{final_port}",
                            redirect_chain=redirect_chain,
                            waf=waf,
                            technologies=technologies
                        )
                except ssl.SSLCertVerificationError as e:
                    logger.warning(f"SSL certificate verification failed for {proto}: {e}")
                    # Continue to next protocol
                except (aiohttp.ClientError, asyncio.TimeoutError) as e:
                    logger.debug(f"Failed with {proto}: {e}")
                    continue
                except Exception as e:
                    logger.debug(f"Unexpected error with {proto}: {e}")
                    continue

        logger.error(f"Could not resolve target: {target_str}")
        return None

    @staticmethod
    def _get_port(port: Optional[int], protocol: str) -> int:
        if port:
            return port
        return 443 if protocol == "https" else 80

    @staticmethod
    async def _detect_waf(response: aiohttp.ClientResponse) -> Optional[str]:
        """Detect Web Application Firewall from response headers."""
        headers = dict(response.headers)
        
        for waf_name, signatures in WAF_SIGNATURES.items():
            for signature in signatures:
                # Check headers
                for header_name, header_value in headers.items():
                    if signature.lower() in header_name.lower() or signature.lower() in header_value.lower():
                        return waf_name
                
                # Check cookies
                if 'set-cookie' in headers:
                    cookie = headers.get('set-cookie', '')
                    if signature.lower() in cookie.lower():
                        return waf_name
        
        return None

    @staticmethod
    async def _detect_technologies(response: aiohttp.ClientResponse) -> List[str]:
        """Detect technologies from response headers and content."""
        technologies = []
        headers = dict(response.headers)
        
        # Server header
        if 'server' in headers:
            server = headers['server']
            technologies.append(f"Server: {server}")
            
            # Extract version if present
            if '/' in server:
                name, version = server.split('/', 1)
                technologies.append(f"{name} {version}")
        
        # X-Powered-By header
        if 'x-powered-by' in headers:
            technologies.append(f"Powered by: {headers['x-powered-by']}")
        
        # Framework detection
        if 'x-aspnet-version' in headers:
            technologies.append(f"ASP.NET {headers['x-aspnet-version']}")
        if 'x-drupal-cache' in headers:
            technologies.append("Drupal")
        if 'x-drupal-dynamic-cache' in headers:
            technologies.append("Drupal")
        if 'x-generator' in headers:
            technologies.append(f"Generator: {headers['x-generator']}")
        
        return technologies

# ============================================================================
# PORT SCANNER (Optimized with worker pool)
# ============================================================================

class PortScanner:
    """Asynchronous TCP port scanner with worker pool for optimal performance."""

    def __init__(self, num_workers: int = 100, timeout: int = 2):
        self.num_workers = num_workers
        self.timeout = timeout
        self.queue = Queue()
        self.results: List[PortInfo] = []
        self.active_workers = 0

    async def scan(self, host: str, ports: List[int] = None) -> List[PortInfo]:
        """Scan ports using a worker pool for better memory efficiency."""
        if ports is None:
            ports = COMMON_PORTS

        logger.info(f"Starting port scan on {host} ({len(ports)} ports with {self.num_workers} workers)")
        
        # Fill queue with ports to scan
        for port in ports:
            await self.queue.put(port)
        
        # Start worker tasks
        workers = []
        for i in range(self.num_workers):
            worker = asyncio.create_task(self._worker(host, i))
            workers.append(worker)
            self.active_workers += 1
        
        # Wait for all workers to complete
        await self.queue.join()
        
        # Cancel workers
        for worker in workers:
            worker.cancel()
        
        # Wait for workers to finish
        await asyncio.gather(*workers, return_exceptions=True)
        
        logger.info(f"Port scan completed. Found {len(self.results)} open ports.")
        return self.results

    async def _worker(self, host: str, worker_id: int):
        """Worker process that scans ports from the queue."""
        while True:
            try:
                port = await self.queue.get()
                result = await self._check_port(host, port)
                if result:
                    self.results.append(result)
                self.queue.task_done()
            except asyncio.CancelledError:
                break
            except Exception as e:
                logger.debug(f"Worker {worker_id} error: {e}")
                self.queue.task_done()

    async def _check_port(self, host: str, port: int) -> Optional[PortInfo]:
        """Check a single port and grab banner if open."""
        try:
            # Attempt connection
            reader, writer = await asyncio.wait_for(
                asyncio.open_connection(host, port),
                timeout=self.timeout
            )

            port_info = PortInfo(port=port, state="open")

            # Enhanced banner grabbing with service-specific probes
            banner = await self._grab_banner(reader, writer, port)
            if banner:
                port_info.banner = banner.decode('utf-8', errors='ignore').strip()
                
                # Detect service and version
                service_info = await self._detect_service(port, port_info.banner)
                port_info.service = service_info["service"]
                port_info.version = service_info["version"]
                port_info.confidence = service_info["confidence"]
                
                # Check for CVEs
                port_info.cves = await self._check_cves(port_info.service, port_info.version)

            writer.close()
            await writer.wait_closed()
            return port_info

        except (asyncio.TimeoutError, ConnectionRefusedError, OSError):
            return None
        except Exception as e:
            logger.debug(f"Error scanning port {port}: {e}")
            return None

    async def _grab_banner(self, reader: asyncio.StreamReader, writer: asyncio.StreamWriter, port: int) -> Optional[bytes]:
        """Grab banner with service-specific probes."""
        probes = {
            21: b"HELP\r\n",
            22: b"\r\n",
            25: b"HELP\r\n",
            80: b"HEAD / HTTP/1.0\r\n\r\n",
            110: b"HELP\r\n",
            143: b"a001 CAPABILITY\r\n",
            443: b"HEAD / HTTP/1.0\r\n\r\n",
            3306: b"\r\n",
            5432: b"\r\n",
            6379: b"INFO\r\n",
            27017: b"\r\n"
        }
        
        try:
            # Send probe if available for this port
            if port in probes:
                writer.write(probes[port])
                await writer.drain()
            
            # Read response
            banner = await asyncio.wait_for(reader.read(1024), timeout=2)
            return banner
        except:
            return None

    async def _detect_service(self, port: int, banner: str) -> Dict[str, Any]:
        """Detect service and version from banner."""
        result = {"service": "unknown", "version": "", "confidence": 0.5}
        banner_lower = banner.lower()
        
        # Check against service patterns
        for service, patterns in SERVICE_PATTERNS.items():
            for pattern in patterns:
                if isinstance(pattern, bytes):
                    pattern = pattern.decode()
                if pattern.lower() in banner_lower:
                    result["service"] = service
                    result["confidence"] = 0.8
                    
                    # Try to extract version
                    version_match = re.search(r'[\d\.]+[a-z]*', banner)
                    if version_match:
                        result["version"] = version_match.group()
                    break
        
        # Fallback to port mapping if no pattern matched
        if result["service"] == "unknown":
            common_services = {
                21: "ftp", 22: "ssh", 23: "telnet", 25: "smtp", 53: "dns",
                80: "http", 110: "pop3", 111: "rpcbind", 135: "msrpc",
                139: "netbios-ssn", 143: "imap", 443: "https", 445: "microsoft-ds",
                993: "imaps", 995: "pop3s", 1723: "pptp", 3306: "mysql",
                3389: "ms-wbt-server", 5432: "postgresql", 5900: "vnc",
                6379: "redis", 8080: "http-proxy", 8443: "https-alt",
                27017: "mongod", 9200: "elasticsearch"
            }
            result["service"] = common_services.get(port, "unknown")
            result["confidence"] = 0.5
        
        return result

    async def _check_cves(self, service: str, version: str) -> List[str]:
        """Check for known CVEs based on service and version."""
        cves = []
        
        # Check against CVE patterns
        for svc, versions in CVE_PATTERNS.items():
            if svc in service.lower():
                for ver, cve_list in versions.items():
                    if version.startswith(ver):
                        cves.extend(cve_list)
        
        return cves

# ============================================================================
# WEB VULNERABILITY SCANNER (Enhanced with better detection)
# ============================================================================

class WebScanner:
    """Performs web application vulnerability checks with enhanced detection."""

    def __init__(self, session: aiohttp.ClientSession, config: 'ScannerConfig'):
        self.session = session
        self.config = config
        self.total_requests = 0
        self.findings: List[Vulnerability] = []
        self.semaphore = Semaphore(config.rate_limit)
        self.baseline_responses: Dict[str, str] = {}  # Store baseline for comparison

    async def scan(self, target: ScanTarget) -> List[Vulnerability]:
        """Run all vulnerability checks on the target."""
        logger.info(f"Starting web vulnerability scan on {target.base_url}")

        # Get baseline response for boolean-based detection
        await self._get_baseline(target)

        # Basic checks
        await self._check_security_headers(target)
        await self._check_directory_exposure(target)
        await self._check_tls_ssl(target)
        await self._check_misconfigurations(target)

        # Aggressive checks (if enabled)
        if self.config.aggressive:
            logger.info("Aggressive mode enabled: Running injection tests.")
            await self._check_sql_injection_enhanced(target)
            await self._check_xss_enhanced(target)
            await self._check_time_based_sql(target)

        logger.info(f"Web scan completed. Found {len(self.findings)} issues.")
        return self.findings

    async def _get_baseline(self, target: ScanTarget):
        """Get baseline response for comparison in boolean-based tests."""
        response = await self._make_request('GET', target.base_url)
        if response:
            self.baseline_responses['base'] = await response.text()

    async def _make_request(self, method: str, url: str, **kwargs) -> Optional[aiohttp.ClientResponse]:
        """Make a rate-limited request with proper SSL handling."""
        async with self.semaphore:
            try:
                self.total_requests += 1
                kwargs.setdefault('timeout', aiohttp.ClientTimeout(total=self.config.timeout))
                kwargs.setdefault('allow_redirects', True)
                kwargs.setdefault('ssl', create_ssl_context())  # Use proper SSL context
                
                # Add random user agent
                headers = kwargs.get('headers', {})
                if 'User-Agent' not in headers:
                    headers['User-Agent'] = self._get_random_user_agent()
                    kwargs['headers'] = headers
                
                # Add proxy if configured
                if self.config.proxy:
                    kwargs['proxy'] = self.config.proxy
                
                response = await self.session.request(method, url, **kwargs)
                return response
            except ssl.SSLCertVerificationError as e:
                logger.debug(f"SSL certificate error for {url}: {e}")
                # Still return response if possible, but note the issue
                return None
            except Exception as e:
                logger.debug(f"Request failed for {url}: {e}")
                return None

    def _get_random_user_agent(self) -> str:
        """Get a random user agent to avoid detection."""
        user_agents = [
            "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36",
            "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/14.0 Safari/605.1.15",
            "Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/92.0.4515.107 Safari/537.36",
            "Mozilla/5.0 (iPhone; CPU iPhone OS 14_6 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/14.0 Mobile/15E148 Safari/604.1"
        ]
        return random.choice(user_agents)

    async def _check_security_headers(self, target: ScanTarget):
        """Check for missing security headers."""
        response = await self._make_request('GET', target.base_url)
        if not response:
            return

        headers = {k.lower(): v for k, v in response.headers.items()}
        
        for header, info in SECURITY_HEADERS.items():
            header_lower = header.lower()
            if header_lower not in headers:
                vuln = Vulnerability(
                    name=f"Missing Security Header: {header}",
                    severity=info["severity"],
                    endpoint=target.base_url,
                    method="GET",
                    status_code=response.status,
                    response_snippet=f"Header '{header}' not found.",
                    description=info["description"],
                    confidence="High",
                    confidence_score=0.9,
                    remediation=info["remediation"]
                )
                self.findings.append(vuln)
            else:
                # Check header values for weaknesses
                value = headers[header_lower]
                if header == "Strict-Transport-Security" and "max-age=0" in value:
                    vuln = Vulnerability(
                        name="Weak HSTS Configuration",
                        severity="Medium",
                        endpoint=target.base_url,
                        method="GET",
                        status_code=response.status,
                        response_snippet=f"HSTS has max-age=0, disabling protection.",
                        description="HSTS is configured with max-age=0, which disables HTTPS enforcement.",
                        confidence="High",
                        confidence_score=0.9,
                        remediation="Set HSTS max-age to at least 31536000 (1 year)."
                    )
                    self.findings.append(vuln)

    async def _check_directory_exposure(self, target: ScanTarget):
        """Check for exposed sensitive directories/files."""
        for path in SENSITIVE_PATHS:
            url = urljoin(target.base_url, path)
            response = await self._make_request('GET', url)

            if response:
                content = await response.text() if response.status == 200 else ""
                
                # Check for sensitive content
                if response.status == 200:
                    # Check if it's not just a 200 OK page (like a custom 404)
                    if "404" not in content and "not found" not in content.lower():
                        # Check for specific sensitive content
                        sensitivity_score = self._check_sensitivity(content, path)
                        
                        if sensitivity_score > 0.5:
                            severity = "High" if sensitivity_score > 0.8 else "Medium"
                            vuln = Vulnerability(
                                name="Sensitive File Exposure",
                                severity=severity,
                                endpoint=url,
                                method="GET",
                                status_code=200,
                                response_snippet=f"Accessed {path} - contains sensitive data (confidence: {sensitivity_score:.1%})",
                                description=f"A sensitive path '{path}' is publicly accessible and may contain sensitive information.",
                                confidence="High" if sensitivity_score > 0.8 else "Medium",
                                confidence_score=sensitivity_score,
                                remediation="Restrict access to sensitive files. Use proper access controls and remove sensitive files from webroot."
                            )
                            self.findings.append(vuln)
                
                # Check for directory listing
                elif response.status == 403 and "Index of" in content:
                    vuln = Vulnerability(
                        name="Directory Listing Enabled",
                        severity="Medium",
                        endpoint=url,
                        method="GET",
                        status_code=403,
                        response_snippet="Directory listing is enabled.",
                        description=f"Directory listing is enabled for {path}, potentially exposing file structure.",
                        confidence="High",
                        confidence_score=0.9,
                        remediation="Disable directory listing in web server configuration."
                    )
                    self.findings.append(vuln)

    def _check_sensitivity(self, content: str, path: str) -> float:
        """Check content for sensitive data patterns."""
        sensitivity_patterns = {
            "password": 0.9,
            "passwd": 0.9,
            "api_key": 0.9,
            "api-key": 0.9,
            "secret": 0.8,
            "token": 0.7,
            "auth": 0.6,
            "mysql": 0.6,
            "database": 0.6,
            "db_": 0.6,
            "username": 0.5,
            "user": 0.4,
            "admin": 0.3
        }
        
        max_score = 0.0
        content_lower = content.lower()
        
        for pattern, score in sensitivity_patterns.items():
            if pattern in content_lower:
                max_score = max(max_score, score)
        
        # Check for path-specific sensitivity
        if ".env" in path:
            max_score = max(max_score, 0.9)
        if "wp-config" in path:
            max_score = max(max_score, 0.9)
        if ".git" in path:
            max_score = max(max_score, 0.8)
        
        return max_score

    async def _check_tls_ssl(self, target: ScanTarget):
        """Check for TLS/SSL issues with proper certificate validation."""
        if target.protocol != "https":
            vuln = Vulnerability(
                name="Missing HTTPS",
                severity="High",
                endpoint=target.base_url,
                method="GET",
                description="The site does not use HTTPS, making all data transmission vulnerable to interception.",
                confidence="High",
                confidence_score=0.9,
                remediation="Enforce HTTPS by obtaining and installing a valid SSL/TLS certificate and redirecting all HTTP traffic to HTTPS."
            )
            self.findings.append(vuln)
            return

        # Certificate check with proper SSL context
        try:
            host = target.resolved_host
            port = target.port
            context = create_ssl_context()
            
            with context.wrap_socket(socket.socket(), server_hostname=host) as s:
                s.settimeout(self.config.timeout)
                s.connect((host, port))
                cert = s.getpeercert()

                # Check expiration
                if cert:
                    # Parse certificate dates
                    not_after = cert.get('notAfter', '')
                    if not_after:
                        exp_date = datetime.strptime(not_after, '%b %d %H:%M:%S %Y %Z')
                        if exp_date < datetime.now():
                            vuln = Vulnerability(
                                name="Expired SSL/TLS Certificate",
                                severity="High",
                                endpoint=target.base_url,
                                description=f"Certificate expired on {exp_date.strftime('%Y-%m-%d')}.",
                                confidence="High",
                                confidence_score=0.9,
                                remediation="Renew the SSL/TLS certificate immediately."
                            )
                            self.findings.append(vuln)
                        elif (exp_date - datetime.now()).days < 30:
                            vuln = Vulnerability(
                                name="Certificate Expiring Soon",
                                severity="Medium",
                                endpoint=target.base_url,
                                description=f"Certificate expires on {exp_date.strftime('%Y-%m-%d')}.",
                                confidence="High",
                                confidence_score=0.8,
                                remediation="Renew the SSL/TLS certificate before it expires."
                            )
                            self.findings.append(vuln)
                    
                    # Check for weak signature algorithm
                    sig_alg = cert.get('signatureAlgorithm', '')
                    if 'sha1' in sig_alg.lower():
                        vuln = Vulnerability(
                            name="Weak Certificate Signature Algorithm",
                            severity="Medium",
                            endpoint=target.base_url,
                            description=f"Certificate uses weak signature algorithm: {sig_alg}",
                            confidence="High",
                            confidence_score=0.8,
                            remediation="Replace certificate with one using SHA-256 or stronger."
                        )
                        self.findings.append(vuln)

        except ssl.SSLCertVerificationError as e:
            vuln = Vulnerability(
                name="SSL Certificate Verification Failed",
                severity="High",
                endpoint=target.base_url,
                description=f"SSL certificate validation failed: {str(e)}",
                confidence="High",
                confidence_score=0.9,
                remediation="Ensure the certificate is valid and properly configured."
            )
            self.findings.append(vuln)
        except Exception as e:
            logger.debug(f"TLS check failed: {e}")

    async def _check_misconfigurations(self, target: ScanTarget):
        """Check for common misconfigurations."""
        # Check for HTTP methods
        dangerous_methods = ['PUT', 'DELETE', 'TRACE', 'CONNECT']
        for method in dangerous_methods:
            response = await self._make_request(method, target.base_url)
            if response and response.status not in [405, 501]:  # Method not allowed/not implemented
                vuln = Vulnerability(
                    name=f"Dangerous HTTP Method Enabled: {method}",
                    severity="Medium",
                    endpoint=target.base_url,
                    method=method,
                    status_code=response.status,
                    description=f"The {method} method is enabled, which could lead to unauthorized modifications.",
                    confidence="Medium",
                    confidence_score=0.6,
                    remediation=f"Disable the {method} HTTP method unless absolutely required."
                )
                self.findings.append(vuln)

        # Check for CORS misconfiguration
        response = await self._make_request('OPTIONS', target.base_url, headers={'Origin': 'https://evil.com'})
        if response:
            allow_origin = response.headers.get('Access-Control-Allow-Origin', '')
            if allow_origin == '*' or allow_origin == 'https://evil.com':
                vuln = Vulnerability(
                    name="CORS Misconfiguration",
                    severity="Medium",
                    endpoint=target.base_url,
                    method="OPTIONS",
                    status_code=response.status,
                    description=f"CORS allows arbitrary origins: {allow_origin}",
                    confidence="High",
                    confidence_score=0.8,
                    remediation="Restrict CORS to trusted domains only. Avoid using wildcard '*'."
                )
                self.findings.append(vuln)

    async def _check_sql_injection_enhanced(self, target: ScanTarget):
        """Enhanced SQL injection detection with boolean-based and time-based checks."""
        # Test common parameters
        test_params = ['id', 'page', 'user', 'product', 'category', 'q', 'search', 'query', 'term']
        
        for param in test_params:
            # Error-based detection
            await self._check_error_based_sql(target, param)
            
            # Boolean-based detection
            await self._check_boolean_based_sql(target, param)
            
            # Stop if we found a vulnerability
            if any(v.name == "SQL Injection" for v in self.findings):
                break

    async def _check_error_based_sql(self, target: ScanTarget, param: str):
        """Check for error-based SQL injection."""
        test_payloads = ["'", "\"", "' OR '1'='1", "' OR 1=1--", "1' AND '1'='1"]
        
        for payload in test_payloads:
            url = f"{target.base_url}?{param}={quote(payload)}"
            response = await self._make_request('GET', url)

            if response and response.status == 200:
                text = (await response.text()).lower()
                
                # Check for SQL errors with pattern matching
                max_weight = 0.0
                matched_patterns = []
                
                for error_info in SQL_ERROR_PATTERNS:
                    if re.search(error_info["pattern"], text, re.IGNORECASE):
                        max_weight = max(max_weight, error_info["weight"])
                        matched_patterns.append(error_info["type"])
                
                if max_weight > 0.6:
                    confidence = "High" if max_weight > 0.8 else "Medium"
                    vuln = Vulnerability(
                        name="SQL Injection",
                        severity="Critical",
                        endpoint=url,
                        method="GET",
                        payload=payload,
                        status_code=200,
                        response_snippet=f"SQL error patterns detected: {', '.join(matched_patterns)}",
                        description=f"The parameter '{param}' may be vulnerable to SQL injection. Server returned SQL errors when injecting '{payload}'.",
                        confidence=confidence,
                        confidence_score=max_weight,
                        remediation="Use parameterized queries/prepared statements. Validate and sanitize all user inputs."
                    )
                    self.findings.append(vuln)
                    return

    async def _check_boolean_based_sql(self, target: ScanTarget, param: str):
        """Check for boolean-based blind SQL injection."""
        if 'base' not in self.baseline_responses:
            return
        
        baseline = self.baseline_responses['base']
        baseline_hash = hashlib.md5(baseline.encode()).hexdigest()
        
        for test in BOOLEAN_SQL_PAYLOADS:
            url = f"{target.base_url}?{param}={quote(test['payload'])}"
            response = await self._make_request('GET', url)
            
            if response and response.status == 200:
                content = await response.text()
                content_hash = hashlib.md5(content.encode()).hexdigest()
                
                # Check if response differs significantly
                similarity = self._calculate_similarity(baseline, content)
                
                # Boolean logic: true conditions should return similar content, false should differ
                if test["true_condition"] and similarity < 0.9:
                    # True condition should be similar, but isn't
                    vuln = Vulnerability(
                        name="Potential Boolean-Based SQL Injection",
                        severity="High",
                        endpoint=url,
                        method="GET",
                        payload=test['payload'],
                        status_code=200,
                        response_snippet=f"Boolean test shows unexpected behavior. Similarity: {similarity:.2%}",
                        description=f"The parameter '{param}' shows behavioral changes with boolean SQL payloads, suggesting blind SQL injection.",
                        confidence="Medium",
                        confidence_score=0.7,
                        remediation="Use parameterized queries. Implement consistent error handling."
                    )
                    self.findings.append(vuln)
                    return
                elif not test["true_condition"] and similarity > 0.95:
                    # False condition should differ, but doesn't
                    vuln = Vulnerability(
                        name="Potential Boolean-Based SQL Injection",
                        severity="High",
                        endpoint=url,
                        method="GET",
                        payload=test['payload'],
                        status_code=200,
                        response_snippet=f"Boolean test shows unexpected behavior. Similarity: {similarity:.2%}",
                        description=f"The parameter '{param}' shows behavioral changes with boolean SQL payloads, suggesting blind SQL injection.",
                        confidence="Medium",
                        confidence_score=0.7,
                        remediation="Use parameterized queries. Implement consistent error handling."
                    )
                    self.findings.append(vuln)
                    return

    async def _check_time_based_sql(self, target: ScanTarget):
        """Check for time-based blind SQL injection."""
        if not self.config.aggressive:
            return
            
        test_params = ['id', 'page']
        
        for param in test_params:
            for test in TIME_SQL_PAYLOADS:
                url = f"{target.base_url}?{param}={quote(test['payload'])}"
                
                # Time the request
                start_time = time.time()
                response = await self._make_request('GET', url)
                elapsed = time.time() - start_time
                
                if response and response.status == 200:
                    if elapsed >= test['delay']:
                        vuln = Vulnerability(
                            name=f"Time-Based SQL Injection ({test['type']})",
                            severity="Critical",
                            endpoint=url,
                            method="GET",
                            payload=test['payload'],
                            status_code=200,
                            response_snippet=f"Request took {elapsed:.2f}s (expected delay: {test['delay']}s)",
                            description=f"The parameter '{param}' shows time-based behavior with SQL payloads, indicating blind SQL injection.",
                            confidence="High",
                            confidence_score=0.8,
                            remediation="Use parameterized queries. Implement consistent response times."
                        )
                        self.findings.append(vuln)
                        return

    async def _check_xss_enhanced(self, target: ScanTarget):
        """Enhanced XSS detection with context awareness and encoding bypass."""
        test_params = ['q', 's', 'search', 'query', 'term', 'name', 'user', 'id']
        
        for param in test_params:
            for test in XSS_PAYLOADS:
                url = f"{target.base_url}?{param}={quote(test['payload'])}"
                response = await self._make_request('GET', url)
                
                if response and response.status == 200:
                    text = await response.text()
                    
                    # Check for payload reflection with context awareness
                    reflection_result = self._check_payload_reflection(text, test)
                    
                    if reflection_result['reflected']:
                        confidence = self._calculate_xss_confidence(reflection_result)
                        
                        vuln = Vulnerability(
                            name="Cross-Site Scripting (XSS)",
                            severity="High",
                            endpoint=url,
                            method="GET",
                            payload=test['payload'],
                            status_code=200,
                            response_snippet=f"Payload reflected in {reflection_result['context']} context. Encoding: {test['encoding']}",
                            description=f"The parameter '{param}' reflects user input without proper encoding. Payload appears in {reflection_result['context']} context.",
                            confidence=confidence,
                            confidence_score=reflection_result['confidence'],
                            remediation="Implement context-aware output encoding. Use Content-Security-Policy headers. Validate and sanitize input."
                        )
                        self.findings.append(vuln)
                        return

    def _check_payload_reflection(self, response_text: str, test: Dict) -> Dict:
        """Check if payload is reflected and in what context."""
        result = {
            'reflected': False,
            'context': 'unknown',
            'confidence': 0.0,
            'encoding_detected': None
        }
        
        payload = test['payload']
        
        # Check for exact reflection
        if payload in response_text:
            result['reflected'] = True
            result['context'] = test['context']
            result['confidence'] = 0.9
            
            # Determine context more precisely
            if f">{payload}<" in response_text:
                result['context'] = 'html_tag'
            elif f"'{payload}'" in response_text or f'"{payload}"' in response_text:
                result['context'] = 'attribute'
            elif f"<script" in response_text and payload in response_text:
                result['context'] = 'script_block'
        
        # Check for encoded versions
        elif payload.lower() in response_text.lower():
            # Case-insensitive match suggests weak filtering
            result['reflected'] = True
            result['context'] = 'case_insensitive'
            result['confidence'] = 0.7
        
        # Check for URL-encoded version
        elif quote(payload) in response_text:
            result['reflected'] = True
            result['context'] = 'url_encoded'
            result['encoding_detected'] = 'url'
            result['confidence'] = 0.8
        
        return result

    def _calculate_xss_confidence(self, reflection_result: Dict) -> str:
        """Calculate confidence level for XSS finding."""
        score = reflection_result['confidence']
        
        if reflection_result['context'] in ['html_tag', 'script_block']:
            score += 0.1
        if reflection_result.get('encoding_detected') is None:
            score += 0.1
        if reflection_result['context'] == 'attribute':
            score += 0.05
        
        if score >= 0.9:
            return "High"
        elif score >= 0.7:
            return "Medium"
        else:
            return "Low"

    def _calculate_similarity(self, text1: str, text2: str) -> float:
        """Calculate similarity between two texts (simplified)."""
        if not text1 or not text2:
            return 0.0
        
        # Simple hash-based similarity for speed
        hash1 = hashlib.md5(text1.encode()).hexdigest()
        hash2 = hashlib.md5(text2.encode()).hexdigest()
        
        if hash1 == hash2:
            return 1.0
        
        # Length-based approximation
        len1, len2 = len(text1), len(text2)
        if len1 == 0 or len2 == 0:
            return 0.0
        
        len_ratio = min(len1, len2) / max(len1, len2)
        return len_ratio * 0.5  # Rough approximation

# ============================================================================
# SUBDOMAIN ENUMERATION (Optional)
# ============================================================================

class SubdomainEnumerator:
    """Enumerate subdomains using various techniques."""
    
    COMMON_SUBDOMAINS = [
        "www", "mail", "ftp", "localhost", "webmail", "smtp", "pop", "ns1", "webdisk",
        "ns2", "cpanel", "whm", "autodiscover", "autoconfig", "m", "imap", "test",
        "ns", "blog", "pop3", "dev", "www2", "admin", "forum", "news", "vpn", "ns3",
        "mail2", "new", "mysql", "old", "lists", "support", "mobile", "mx", "static",
        "docs", "api", "beta", "shop", "sql", "secure", "demo", "cp", "calendar",
        "wiki", "web", "media", "email", "images", "img", "download", "dns", "piwik",
        "stats", "dashboard", "portal", "manage", "apps", "video", "sip", "dns2",
        "api2", "cdn", "my", "stage", "mssql", "webmail2", "server", "chat",
        "js", "css", "backup", "tools", "jobs", "cdn2", "staff", "staging", "git",
        "logs", "clients", "assets", "proxy", "help", "internal", "panel", "demo2"
    ]
    
    def __init__(self, session: aiohttp.ClientSession, config: 'ScannerConfig'):
        self.session = session
        self.config = config
        self.semaphore = Semaphore(config.rate_limit)
    
    async def enumerate(self, domain: str) -> List[str]:
        """Enumerate subdomains."""
        if not domain or '.' not in domain:
            return []
        
        logger.info(f"Starting subdomain enumeration for {domain}")
        found = []
        tasks = []
        
        for sub in self.COMMON_SUBDOMAINS:
            subdomain = f"{sub}.{domain}"
            tasks.append(self._check_subdomain(subdomain))
        
        results = await asyncio.gather(*tasks, return_exceptions=True)
        found = [r for r in results if r is not None]
        
        logger.info(f"Found {len(found)} subdomains")
        return found
    
    async def _check_subdomain(self, subdomain: str) -> Optional[str]:
        """Check if subdomain resolves and responds."""
        async with self.semaphore:
            try:
                # Try HTTP first
                for proto in ['https', 'http']:
                    try:
                        url = f"{proto}://{subdomain}"
                        async with self.session.get(url, timeout=5, ssl=create_ssl_context()) as resp:
                            if resp.status < 500:  # Any response means it exists
                                logger.debug(f"Found subdomain: {subdomain}")
                                return subdomain
                    except:
                        continue
            except:
                pass
            return None

# ============================================================================
# EXTERNAL TOOL INTEGRATION (Enhanced)
# ============================================================================

class ExternalToolRunner:
    """Detects and runs external security tools, merging their output."""

    @staticmethod
    async def run_nmap(target: str, ports: str, aggressive: bool = False) -> Optional[Dict]:
        """Run nmap scan if available."""
        if not shutil.which("nmap"):
            logger.info("nmap not found in PATH. Skipping.")
            return None

        logger.info("Running nmap scan (this may take a while)...")
        try:
            cmd = ["nmap", "-sV", "--version-intensity", "5"]
            if aggressive:
                cmd.extend(["-A", "--script", "vuln"])
            cmd.extend(["-p", ports, target])
            
            proc = await asyncio.create_subprocess_exec(
                *cmd,
                stdout=asyncio.subprocess.PIPE,
                stderr=asyncio.subprocess.PIPE
            )
            stdout, stderr = await proc.communicate()

            # Parse nmap output for services
            services = []
            for line in stdout.decode('utf-8', errors='ignore').split('\n'):
                if '/tcp' in line and 'open' in line:
                    services.append(line.strip())

            return {
                "tool": "nmap",
                "command": " ".join(cmd),
                "output": stdout.decode('utf-8', errors='ignore'),
                "errors": stderr.decode('utf-8', errors='ignore'),
                "services": services
            }
        except Exception as e:
            logger.error(f"Failed to run nmap: {e}")
            return None

    @staticmethod
    async def run_nikto(target: str) -> Optional[Dict]:
        """Run nikto scan if available."""
        if not shutil.which("nikto"):
            logger.info("nikto not found in PATH. Skipping.")
            return None

        logger.info("Running nikto web scan...")
        try:
            cmd = ["nikto", "-h", target, "-Format", "json", "-nointeractive"]
            proc = await asyncio.create_subprocess_exec(
                *cmd,
                stdout=asyncio.subprocess.PIPE,
                stderr=asyncio.subprocess.PIPE
            )
            stdout, stderr = await proc.communicate()

            return {
                "tool": "nikto",
                "command": " ".join(cmd),
                "output": stdout.decode('utf-8', errors='ignore'),
                "errors": stderr.decode('utf-8', errors='ignore')
            }
        except Exception as e:
            logger.error(f"Failed to run nikto: {e}")
            return None

    @staticmethod
    async def run_sqlmap(target: str, aggressive: bool = False) -> Optional[Dict]:
        """Run sqlmap for SQL injection detection (safe mode only)."""
        if not shutil.which("sqlmap"):
            logger.info("sqlmap not found in PATH. Skipping.")
            return None

        logger.info("Running sqlmap (safe detection mode)...")
        try:
            cmd = ["sqlmap", "-u", target, "--batch", "--smart", "--level=1", "--risk=1"]
            if not aggressive:
                cmd.append("--detect-level=1")
            
            proc = await asyncio.create_subprocess_exec(
                *cmd,
                stdout=asyncio.subprocess.PIPE,
                stderr=asyncio.subprocess.PIPE
            )
            stdout, stderr = await proc.communicate()

            return {
                "tool": "sqlmap",
                "command": " ".join(cmd),
                "output": stdout.decode('utf-8', errors='ignore'),
                "errors": stderr.decode('utf-8', errors='ignore')
            }
        except Exception as e:
            logger.error(f"Failed to run sqlmap: {e}")
            return None

# ============================================================================
# REPORT GENERATOR (Enhanced)
# ============================================================================

class ReportGenerator:
    """Generates terminal, JSON, and HTML reports with enhanced formatting."""

    def __init__(self, result: ScanResult, config: 'ScannerConfig'):
        self.result = result
        self.config = config

    def generate_terminal_report(self):
        """Print a summary to the terminal with color coding."""
        duration = (self.result.end_time - self.result.start_time).total_seconds()
        
        # ANSI color codes
        RED = '\033[91m'
        YELLOW = '\033[93m'
        GREEN = '\033[92m'
        BLUE = '\033[94m'
        MAGENTA = '\033[95m'
        CYAN = '\033[96m'
        WHITE = '\033[97m'
        BOLD = '\033[1m'
        END = '\033[0m'
        
        print("\n" + "="*80)
        print(f"{BOLD}SCAN COMPLETE{END}".center(80))
        print("="*80)
        print(f"{BOLD}Target:{END} {self.result.target.original}")
        print(f"{BOLD}Resolved:{END} {self.result.target.base_url}")
        print(f"{BOLD}Protocol:{END} {self.result.target.protocol.upper()}")
        print(f"{BOLD}Port:{END} {self.result.target.port}")
        if self.result.target.waf:
            print(f"{BOLD}WAF Detected:{END} {self.result.target.waf}")
        if self.result.target.technologies:
            print(f"{BOLD}Technologies:{END} {', '.join(self.result.target.technologies[:5])}")
        print(f"{BOLD}Duration:{END} {duration:.2f} seconds")
        print(f"{BOLD}Total Requests:{END} {self.result.total_requests}")
        print(f"{BOLD}Vulnerabilities Found:{END} {len(self.result.vulnerabilities)}")
        print("-"*80)

        if self.result.open_ports:
            print(f"\n{BOLD}Open Ports & Services:{END}")
            print(f"{'PORT':<8} {'SERVICE':<15} {'VERSION':<15} {'CONFIDENCE':<10} {'CVEs'}")
            print("-"*70)
            for port in sorted(self.result.open_ports, key=lambda x: x.port):
                cve_str = ', '.join(port.cves[:2]) if port.cves else ''
                confidence = f"{port.confidence:.0%}"
                version = port.version if port.version else '-'
                print(f"{port.port:<8} {port.service:<15} {version:<15} {confidence:<10} {cve_str}")
        else:
            print(f"\n{YELLOW}No open ports found.{END}")

        if self.result.vulnerabilities:
            print(f"\n{BOLD}Vulnerabilities by Severity:{END}")
            by_severity = {"Critical": [], "High": [], "Medium": [], "Low": [], "Info": []}
            for v in self.result.vulnerabilities:
                by_severity[v.severity].append(v)

            for severity in ["Critical", "High", "Medium", "Low", "Info"]:
                if by_severity[severity]:
                    color = RED if severity == "Critical" else YELLOW if severity == "High" else CYAN if severity == "Medium" else GREEN
                    print(f"\n{color}{BOLD}{severity}:{END}")
                    for v in by_severity[severity]:
                        confidence_color = GREEN if v.confidence == "High" else YELLOW
                        print(f"  • {v.name}")
                        print(f"    {CYAN}Endpoint:{END} {v.endpoint}")
                        print(f"    {CYAN}Confidence:{END} {confidence_color}{v.confidence}{END} ({v.confidence_score:.0%})")
                        if v.cve:
                            print(f"    {CYAN}CVE:{END} {RED}{v.cve}{END}")
                        if v.remediation:
                            print(f"    {CYAN}Fix:{END} {v.remediation[:100]}...")
        else:
            print(f"\n{GREEN}No vulnerabilities detected.{END}")

        if self.result.subdomains:
            print(f"\n{BOLD}Discovered Subdomains:{END}")
            for sub in self.result.subdomains[:10]:
                print(f"  • {sub}")

        if self.result.external_tool_results:
            print(f"\n{BOLD}External Tools Run:{END}")
            for tool_name in self.result.external_tool_results:
                print(f"  • {tool_name}")

    def generate_json_report(self) -> str:
        """Return JSON string of results."""
        def json_serial(obj):
            """JSON serializer for objects not serializable by default json code."""
            if isinstance(obj, datetime):
                return obj.isoformat()
            if hasattr(obj, '__dict__'):
                return obj.__dict__
            raise TypeError(f"Type {type(obj)} not serializable")

        data = {
            "scan_info": {
                "target": asdict(self.result.target),
                "start_time": self.result.start_time.isoformat(),
                "end_time": self.result.end_time.isoformat() if self.result.end_time else None,
                "duration": (self.result.end_time - self.result.start_time).total_seconds() if self.result.end_time else 0,
                "total_requests": self.result.total_requests,
                "config": asdict(self.config)
            },
            "open_ports": [asdict(p) for p in self.result.open_ports],
            "vulnerabilities": [asdict(v) for v in self.result.vulnerabilities],
            "subdomains": self.result.subdomains,
            "external_tools": self.result.external_tool_results
        }
        return json.dumps(data, indent=2, default=json_serial)

    def generate_html_report(self) -> str:
        """Generate a styled HTML report with enhanced formatting."""
        duration = (self.result.end_time - self.result.start_time).total_seconds() if self.result.end_time else 0
        
        # Group vulnerabilities by severity
        by_severity = {"Critical": [], "High": [], "Medium": [], "Low": [], "Info": []}
        for v in self.result.vulnerabilities:
            by_severity[v.severity].append(v)

        # Severity colors
        severity_colors = {
            "Critical": "#d9534f",
            "High": "#f0ad4e",
            "Medium": "#5bc0de",
            "Low": "#5cb85c",
            "Info": "#777"
        }

        html_content = f"""<!DOCTYPE html>
<html>
<head>
    <title>Vulnerability Scan Report - {self.result.target.original}</title>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <style>
        body {{ font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; margin: 0; padding: 20px; background: #f5f5f5; }}
        .container {{ max-width: 1400px; margin: auto; background: white; padding: 30px; border-radius: 10px; box-shadow: 0 4px 6px rgba(0,0,0,0.1); }}
        h1, h2, h3 {{ color: #333; margin-top: 30px; }}
        h1 {{ border-bottom: 3px solid #5bc0de; padding-bottom: 10px; }}
        h2 {{ border-bottom: 2px solid #eee; padding-bottom: 5px; }}
        .summary {{ background: #e8f4f8; padding: 20px; border-radius: 8px; margin: 20px 0; }}
        .summary-grid {{ display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 15px; }}
        .stat-card {{ background: white; padding: 15px; border-radius: 5px; box-shadow: 0 2px 4px rgba(0,0,0,0.05); }}
        .stat-label {{ color: #666; font-size: 0.9em; }}
        .stat-value {{ font-size: 1.8em; font-weight: bold; color: #333; }}
        .vuln {{ margin: 15px 0; padding: 15px; border-left: 4px solid; border-radius: 0 5px 5px 0; background: #fafafa; }}
        .severity-badge {{ display: inline-block; padding: 3px 10px; border-radius: 3px; color: white; font-size: 12px; font-weight: bold; }}
        table {{ width: 100%; border-collapse: collapse; margin: 20px 0; background: white; }}
        th, td {{ padding: 12px; text-align: left; border-bottom: 1px solid #ddd; }}
        th {{ background-color: #f2f2f2; font-weight: bold; }}
        tr:hover {{ background-color: #f5f5f5; }}
        .port-info {{ background: #f9f9f9; padding: 10px; border-radius: 5px; }}
        .cve-tag {{ background: #d9534f; color: white; padding: 2px 6px; border-radius: 3px; font-size: 11px; margin-right: 5px; }}
        .progress-bar {{ width: 100%; height: 20px; background: #eee; border-radius: 10px; overflow: hidden; }}
        .progress-fill {{ height: 100%; background: #5cb85c; transition: width 0.3s; }}
        .confidence-high {{ background: #d9534f; color: white; }}
        .confidence-medium {{ background: #f0ad4e; color: white; }}
        .confidence-low {{ background: #5bc0de; color: white; }}
        .tool-output {{ background: #2d2d2d; color: #f8f8f8; padding: 15px; border-radius: 5px; overflow-x: auto; font-family: 'Courier New', monospace; font-size: 13px; }}
        .redirect-chain {{ background: #f0f0f0; padding: 10px; border-radius: 5px; word-break: break-all; }}
        .tech-tag {{ background: #337ab7; color: white; padding: 2px 8px; border-radius: 3px; display: inline-block; margin: 2px; }}
        @media print {{ body {{ background: white; }} .container {{ box-shadow: none; }} }}
    </style>
</head>
<body>
    <div class="container">
        <h1>🔍 Vulnerability Scan Report</h1>
        
        <div class="summary">
            <h2>Scan Summary</h2>
            <div class="summary-grid">
                <div class="stat-card">
                    <div class="stat-label">Target</div>
                    <div class="stat-value">{self.result.target.original}</div>
                </div>
                <div class="stat-card">
                    <div class="stat-label">Duration</div>
                    <div class="stat-value">{duration:.1f}s</div>
                </div>
                <div class="stat-card">
                    <div class="stat-label">Requests</div>
                    <div class="stat-value">{self.result.total_requests}</div>
                </div>
                <div class="stat-card">
                    <div class="stat-label">Vulnerabilities</div>
                    <div class="stat-value">{len(self.result.vulnerabilities)}</div>
                </div>
            </div>
            
            <h3>Target Details</h3>
            <table>
                <tr><th style="width:150px">Property</th><th>Value</th></tr>
                <tr><td>Resolved URL</td><td>{self.result.target.base_url}</td></tr>
                <tr><td>Protocol</td><td>{self.result.target.protocol.upper()}</td></tr>
                <tr><td>Port</td><td>{self.result.target.port}</td></tr>
                <tr><td>WAF Detected</td><td>{self.result.target.waf or 'None'}</td></tr>
                <tr><td>Technologies</td><td>{', '.join(self.result.target.technologies) if self.result.target.technologies else 'None'}</td></tr>
            </table>
            
            <h3>Redirect Chain</h3>
            <div class="redirect-chain">
                {' → '.join(self.result.target.redirect_chain) if self.result.target.redirect_chain else 'No redirects'}
            </div>
        </div>

        <h2>🌐 Open Ports & Services</h2>
        <table>
            <thead>
                <tr>
                    <th>Port</th>
                    <th>Service</th>
                    <th>Version</th>
                    <th>Banner</th>
                    <th>Confidence</th>
                    <th>CVEs</th>
                </tr>
            </thead>
            <tbody>
                {''.join(f"<tr><td>{p.port}</td><td>{p.service}</td><td>{p.version or '-'}</td><td>{p.banner[:100]}</td><td>{p.confidence:.0%}</td><td>{', '.join(f'<span class=\"cve-tag\">{c}</span>' for c in p.cves[:3])}</td></tr>" for p in sorted(self.result.open_ports, key=lambda x: x.port))}
            </tbody>
        </table>

        <h2>⚠️ Vulnerabilities by Severity</h2>
        {''.join(self._vuln_section_html(severity, by_severity[severity], severity_colors[severity]) for severity in ["Critical", "High", "Medium", "Low", "Info"] if by_severity[severity])}

        {self._external_tools_html()}
        
        {self._subdomains_html()}
        
        <div style="margin-top: 40px; text-align: center; color: #777; font-size: 12px;">
            Generated by Enhanced Vulnerability Scanner v{VERSION} on {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}
        </div>
    </div>
</body>
</html>"""
        return html_content

    def _vuln_section_html(self, severity: str, vulns: List[Vulnerability], color: str) -> str:
        """Generate HTML for a severity section."""
        if not vulns:
            return ""
        
        html = f"""
        <h3 style="color: {color};">{severity} ({len(vulns)})</h3>
        """
        
        for v in vulns:
            confidence_color = "#d9534f" if v.confidence == "High" else "#f0ad4e" if v.confidence == "Medium" else "#5bc0de"
            html += f"""
            <div class="vuln" style="border-left-color: {color};">
                <div style="display: flex; justify-content: space-between; align-items: center;">
                    <h4 style="margin: 0;">{v.name}</h4>
                    <span class="severity-badge" style="background: {color};">{severity}</span>
                </div>
                <p><strong>Endpoint:</strong> {v.endpoint}</p>
                <p><strong>Method:</strong> {v.method}</p>
                <p><strong>Confidence:</strong> <span style="background: {confidence_color}; color: white; padding: 2px 8px; border-radius: 3px;">{v.confidence} ({v.confidence_score:.0%})</span></p>
                <p><strong>Description:</strong> {v.description}</p>
                <p><strong>Remediation:</strong> {v.remediation}</p>
                """
            if v.payload:
                html += f'<p><strong>Payload:</strong> <code>{html.escape(v.payload)}</code></p>'
            if v.cve:
                html += f'<p><strong>CVE:</strong> <a href="https://cve.mitre.org/cgi-bin/cvename.cgi?name={v.cve}" target="_blank">{v.cve}</a></p>'
            if v.response_snippet:
                html += f'<p><strong>Evidence:</strong></p><pre style="background: #f5f5f5; padding: 10px; border-radius: 5px;">{html.escape(v.response_snippet[:500])}</pre>'
            html += "</div>"
        
        return html

    def _external_tools_html(self) -> str:
        """Generate HTML for external tool results."""
        if not self.result.external_tool_results:
            return ""

        html = "<h2>🔧 External Tool Results</h2>"
        for tool_name, result in self.result.external_tool_results.items():
            html += f"""
            <h3>{tool_name.upper()}</h3>
            <div class="tool-output">
                <pre>{html.escape(result.get('output', '')[:2000])}</pre>
            </div>
            """
        return html

    def _subdomains_html(self) -> str:
        """Generate HTML for discovered subdomains."""
        if not self.result.subdomains:
            return ""

        html = "<h2>🌍 Discovered Subdomains</h2><ul>"
        for sub in self.result.subdomains:
            html += f"<li>{sub}</li>"
        html += "</ul>"
        return html

# ============================================================================
# MAIN SCANNER ORCHESTRATOR (Enhanced)
# ============================================================================

@dataclass
class ScannerConfig:
    """Configuration for the scanner."""
    target: str
    ports: str = "common"
    timeout: int = 5
    threads: int = 100
    aggressive: bool = False
    output: str = "scan_report"
    proxy: Optional[str] = None
    rate_limit: int = 10
    enumerate_subdomains: bool = False
    no_external: bool = False

class VulnerabilityScanner:
    """Main orchestrator for the scanning process."""

    def __init__(self, config: ScannerConfig):
        self.config = config
        self.result: Optional[ScanResult] = None
        self.start_time = datetime.now()
        self.session: Optional[aiohttp.ClientSession] = None

    async def run(self):
        """Execute the full scan."""
        # Legal consent
        get_user_consent()

        # Resolve target
        logger.info(f"Resolving target: {self.config.target}")
        target = await TargetResolver.resolve(self.config.target, self.config.timeout)
        if not target:
            logger.error("Target resolution failed. Exiting.")
            return

        logger.info(f"Target resolved: {target.base_url}")
        logger.info(f"Redirect chain: {' -> '.join(target.redirect_chain)}")
        if target.waf:
            logger.info(f"WAF detected: {target.waf}")

        self.result = ScanResult(target=target, start_time=self.start_time)

        # Setup aiohttp session with proper SSL
        connector = aiohttp.TCPConnector(
            limit=self.config.threads,
            ssl=create_ssl_context(),
            force_close=True,
            enable_cleanup_closed=True
        )
        timeout = aiohttp.ClientTimeout(total=self.config.timeout, connect=5, sock_read=10)
        self.session = aiohttp.ClientSession(connector=connector, timeout=timeout)

        try:
            # Port scan with worker pool
            port_scanner = PortScanner(num_workers=self.config.threads, timeout=self.config.timeout)
            open_ports = await port_scanner.scan(target.resolved_host, self._parse_ports())
            self.result.open_ports = open_ports

            # Web vulnerability scan (if web ports are open)
            web_ports = [p for p in open_ports if p.service in ["http", "https", "http-proxy", "https-alt", "http-alt"]]
            if web_ports:
                web_scanner = WebScanner(self.session, self.config)
                vulns = await web_scanner.scan(target)
                self.result.vulnerabilities = vulns
                self.result.total_requests = web_scanner.total_requests

            # Subdomain enumeration (if requested)
            if self.config.enumerate_subdomains:
                enumerator = SubdomainEnumerator(self.session, self.config)
                subdomains = await enumerator.enumerate(target.resolved_host)
                self.result.subdomains = subdomains

            # External tools (optional, ask user)
            if self.config.aggressive and not self.config.no_external:
                run_ext = input("\nRun external tools (nmap, nikto, sqlmap)? This may take significant time. (y/N): ").lower()
                if run_ext == 'y':
                    self.result.external_tool_results = await self._run_external_tools(target)

        except Exception as e:
            logger.error(f"Scan failed: {e}", exc_info=True)
        finally:
            await self.session.close()

        self.result.end_time = datetime.now()
        self._generate_reports()

    def _parse_ports(self) -> List[int]:
        """Parse ports argument into list."""
        if self.config.ports == "common":
            return COMMON_PORTS
        elif self.config.ports == "all":
            return list(range(1, 1025))  # First 1024 ports
        elif '-' in self.config.ports:
            # Range like "1-1000"
            start, end = map(int, self.config.ports.split('-'))
            return list(range(start, end + 1))
        elif ',' in self.config.ports:
            # List like "80,443,8080"
            return [int(p.strip()) for p in self.config.ports.split(',')]
        else:
            # Single port
            return [int(self.config.ports)]

    async def _run_external_tools(self, target: ScanTarget) -> Dict:
        """Run external tools and collect results."""
        results = {}
        host = target.resolved_host
        port_str = ",".join(str(p.port) for p in self.result.open_ports) if self.result.open_ports else "1-1000"

        # Run tools concurrently
        tasks = []
        
        # Nmap
        tasks.append(ExternalToolRunner.run_nmap(host, port_str, self.config.aggressive))
        
        # Nikto (only for web targets)
        if any(p.service in ["http", "https"] for p in self.result.open_ports):
            tasks.append(ExternalToolRunner.run_nikto(target.base_url))
        
        # Sqlmap (aggressive only)
        if self.config.aggressive:
            tasks.append(ExternalToolRunner.run_sqlmap(target.base_url, self.config.aggressive))
        
        results_list = await asyncio.gather(*tasks, return_exceptions=True)
        
        tool_names = ["nmap", "nikto", "sqlmap"]
        for name, res in zip(tool_names, results_list):
            if res and not isinstance(res, Exception):
                results[name] = res

        return results

    def _generate_reports(self):
        """Generate all report formats."""
        if not self.result:
            return

        reporter = ReportGenerator(self.result, self.config)

        # Terminal
        reporter.generate_terminal_report()

        # JSON
        json_report = reporter.generate_json_report()
        with open(f"{self.config.output}.json", "w") as f:
            f.write(json_report)
        logger.info(f"JSON report saved to {self.config.output}.json")

        # HTML
        html_report = reporter.generate_html_report()
        with open(f"{self.config.output}.html", "w") as f:
            f.write(html_report)
        logger.info(f"HTML report saved to {self.config.output}.html")

# ============================================================================
# CLI ENTRY POINT
# ============================================================================

def main():
    parser = argparse.ArgumentParser(
        description="Enhanced Professional Ethical Vulnerability Scanner",
        epilog="Authorized testing only. Ensure you have explicit permission.",
        formatter_class=argparse.RawDescriptionHelpFormatter
    )
    parser.add_argument("--target", required=True, help="Target IP, domain, or URL")
    parser.add_argument("--ports", default="common", 
                       help="Ports to scan (common, all, range like 1-1000, list like 80,443, or single port)")
    parser.add_argument("--timeout", type=int, default=5, help="Request timeout in seconds")
    parser.add_argument("--threads", type=int, default=100, help="Number of concurrent workers")
    parser.add_argument("--aggressive", action="store_true", 
                       help="Enable aggressive (but still safe) tests including time-based SQL injection")
    parser.add_argument("--output", default="scan_report", help="Base name for output files")
    parser.add_argument("--proxy", help="HTTP proxy URL (e.g., http://127.0.0.1:8080)")
    parser.add_argument("--rate-limit", type=int, default=10, help="Max requests per second")
    parser.add_argument("--enumerate-subdomains", action="store_true", help="Enumerate common subdomains")
    parser.add_argument("--no-external", action="store_true", help="Skip external tool integration")
    parser.add_argument("--version", action="version", version=f"Enhanced Vulnerability Scanner v{VERSION}")

    args = parser.parse_args()
    config = ScannerConfig(**vars(args))

    scanner = VulnerabilityScanner(config)
    asyncio.run(scanner.run())

if __name__ == "__main__":
    main()
